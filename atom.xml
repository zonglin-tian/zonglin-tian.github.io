<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Temm&#39;s Zone</title>
  
  <subtitle>test_subtitle</subtitle>
  <link href="https://zonglin-tian.github.io/atom.xml" rel="self"/>
  
  <link href="https://zonglin-tian.github.io/"/>
  <updated>2025-08-22T01:09:37.565Z</updated>
  <id>https://zonglin-tian.github.io/</id>
  
  <author>
    <name>Temm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 常用库</title>
    <link href="https://zonglin-tian.github.io/plib/"/>
    <id>https://zonglin-tian.github.io/plib/</id>
    <published>2025-08-22T01:09:37.565Z</published>
    <updated>2025-08-22T01:09:37.565Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="imageio"><a href="#imageio" class="headerlink" title="imageio"></a><a href="https://pypi.org/project/imageio/">imageio</a></h1><p>用于易于读写各种图像数据 Python 库</p><ul><li>安装: <code>pip install imageio</code></li><li>导入: <code>import imageio.v3 as iio</code></li><li>读取 (uint8 array): <code>img = iio.imread(path_to_file)</code></li><li>保存: <code>iio.imwrite(path_to_save, img)</code></li></ul><h1 id="pyexr"><a href="#pyexr" class="headerlink" title="pyexr"></a><a href="https://pypi.org/project/pyexr/">pyexr</a></h1><p>一个简单的 Python EXR 输入-输出库, 简化 OpenEXR 的使用</p><ul><li>安装: <code>pip install pyexr</code></li><li>读取 <strong>(数值没有做任何处理)</strong>: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># with</span><br><span class="hljs-keyword">with</span> pyexr.<span class="hljs-built_in">open</span>(file.exr) <span class="hljs-keyword">as</span> file:<br>    img = file.get()  <span class="hljs-comment"># (H, W, 3) np.float32 array</span><br><br><span class="hljs-comment"># read</span><br>img = pyexr.read(file.exr)  <span class="hljs-comment"># (H, W, 3) np.float32 array</span><br></code></pre></td></tr></table></figure></li><li>保存: <code>pyexr.write(out.exr, color_array)</code></li></ul><h1 id="ArgumentParser"><a href="#ArgumentParser" class="headerlink" title="ArgumentParser"></a>ArgumentParser</h1><p><code>ArgumentParser</code> 是 Python 标准库 <code>argparse</code> 中的一个类, 用于解析命令行参数, 并自动生成帮助和使用信息: <code>from argparse import ArgumentParser</code></p><h2 id="add-argument-name-or-flags-kwargs"><a href="#add-argument-name-or-flags-kwargs" class="headerlink" title="add_argument(name_or_flags, **kwargs)"></a><code>add_argument(name_or_flags, **kwargs)</code></h2><p><strong>添加命令行参数</strong></p><ul><li><code>name_or_flags</code>: 参数名 (<code>filename</code>) 或选项标志 (<code>-f</code>, <code>--file</code>)<ul><li>定位参数 (<code>&quot;input&quot;</code>): 按顺序提供 (<code>file.txt</code>)</li><li>可选参数 (<code>&quot;--input&quot;</code>, <code>&quot;-i&quot;</code>): 通过标志指定 (<code>--input file.txt</code>)<ul><li>短选项 (<code>-</code>): 高频使用的简单参数</li><li>长选项 (<code>--</code>): 需要明确语义的复杂参数</li></ul></li></ul></li><li>关键字参数 (<code>kwargs</code>)<ul><li><code>type</code>: 参数类型 (<code>int</code>, <code>str</code>)</li><li><code>help</code>: 帮助信息</li><li><code>default</code>: 默认值</li><li><code>action</code>: 特殊行为 (<code>store_true, append</code>)<ul><li><code>store_true</code>: 指定参数, 值为 <code>True</code>, 否则为 <code>False</code></li></ul></li><li><code>choices</code>: 限制参数范围</li><li><code>dest</code>: 解析后属性的名称 (默认取第一个长选项或短选项的名称去掉 <code>-</code>)</li><li><code>required</code>: 是否必填 (针对可选参数)</li></ul></li></ul><h2 id="parse-args"><a href="#parse-args" class="headerlink" title="parse_args()"></a><code>parse_args()</code></h2><p><strong>解析命令行参数 (从 <code>sys.argv</code> 读取), 返回命名空间对象 (<code>Namespace</code>)</strong></p><ul><li><code>parse_args(list(str))</code>: 从列表解析 (而非命令行), 列表格式必须模拟命令行, 可直接控制输入参数, 通常用于测试场景, </li><li><code>parse_known_args()</code>: 忽略未知参数, 解析已知参数, 返回 <code>(args, unknown_args)</code> 元组</li><li><code>Namespace</code> 对象 (<code>argparse</code> 模块中定义的一个类)<ul><li>将解析后的命令行参数存储为对象的动态属性, 通过 <code>args.attribute_name</code> 的方式访问</li><li>属性名与参数名一致, 自动转换短横线为<strong>下划线</strong>), 未指定且无默认值的参数, 属性值为 <code>None</code></li><li>类似于字典, 可通过 <code>vars(args)</code> 转换为字典 (或通过 <code>args.__dict__</code> 查看存储的字典形式)<ul><li><code>Namespace(**dict_name)</code>: 将字典解包为 <code>Namespace</code> 对象</li></ul></li><li><code>hasattr(args, pram_name)</code>: 检查参数是否存在</li><li><code>delattr(args, pram_name)</code>: 删除参数</li><li><code>setattr(args, param_name, value)</code> 或 <code>args.param_name = value</code>: 更新参数 <code>param_name</code> 的值为 <code>value</code></li></ul></li></ul><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ul><li><code>add_argument_group(str)</code>: 在帮助信息中创建分组的参数显示 (逻辑分组, 不影响解析逻辑)</li><li><code>print_help()</code>: 打印帮助信息 (<code>-h</code>)</li></ul><h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><ul><li><a href="https://pythonjishu.com/pandas-dataframe-to_excel/">Pandas 将数据写入 Excel</a></li><li>获取 <em>DataFrame</em> 的所有列名: <code>list(data_frame)</code> (sorted 返回有序)</li></ul><h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><ul><li><a href="https://blog.csdn.net/beautiful77moon/article/details/88877519#:~:text=%E5%9C%A8python%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20datetime%20%E6%9D%A5%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%98%AF%E8%A6%81%E7%8E%B0%E5%AF%BC%E5%85%A5datetime%E5%BA%93%201%20%3E%3E%3E%20%20print%20(datetime.datetime.today()),(datetime.datetime.now())%204%202019%20-03-%2028%2020%3A%2034%3A%2011.377443">获取当前日期&#x2F;时间</a></li><li><a href="https://blog.csdn.net/Gabriel100yi/article/details/135251097#:~:text=%E8%A6%81%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%98%AF%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20date%20%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E3%80%82%20%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E5%A6%82%E4%B8%8B%EF%BC%9A%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E7%9A%84%E5%B9%B4%E4%BB%BD%EF%BC%9A%E4%BD%BF%E7%94%A8%20year%20%E5%B1%9E%E6%80%A7%E3%80%82%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E7%9A%84%E6%9C%88%E4%BB%BD%EF%BC%9A%E4%BD%BF%E7%94%A8,%E4%BD%BF%E7%94%A8%20date%20%E7%B1%BB%E7%9A%84%20timetuple()%20%E6%96%B9%E6%B3%95%E5%B0%86%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%97%B6%E9%97%B4%E5%85%83%E7%BB%84%E3%80%82%20%E4%BD%BF%E7%94%A8%E6%97%B6%E9%97%B4%E5%85%83%E7%BB%84%E4%B8%AD%E7%9A%84%20tm_yday%20%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9%E3%80%82">计算指定日期是一年中的第几天</a></li><li><a href="https://blog.csdn.net/weixin_40012554/article/details/108759160">计算日期差</a></li></ul><h1 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h1><ul><li><code>shutil.copytree(src, dst, dirs_exist_ok=False)</code>: 递归复制目录</li><li><code>shutil.copy2(src, dst)</code>: 复制文件 (保留元数据)</li><li><code>shutil.rmtree(dir_path)</code>: 递归删除<strong>目录</strong>及其内容 (删除非空目录)</li></ul><h1 id="os"><a href="#os" class="headerlink" title="os"></a>os</h1><h2 id="os-path-–-路径操作"><a href="#os-path-–-路径操作" class="headerlink" title="os.path – 路径操作"></a>os.path – 路径操作</h2><ul><li><code>os.path.split(*path*)</code>: 将路径 <em>path</em> 拆分为一对, 即 <code>(head, tail)</code>, 其中 <em>tail</em> 是路径的最后一部分, 而 <em>head</em> 以除最后一部分外的所有内容, tail 部分不会包含斜杠, head 末尾的斜杠会被去掉<ul><li>如果 path 以斜杠结尾, 则 tail 为空</li><li><code>os.path.join(head, tail) == path</code></li><li><code>head == os.path.dirname(path)</code></li><li><code>tail == os.path.basename(path)</code></li></ul></li><li><code>os.path.dirname(path)</code>: 返回路径 path 的目录名称</li><li><code>os.path.basename(path)</code>: 返回路径 path 的基本名称</li><li><code>os.path.join(path, *paths)</code>: 智能地拼接一个或多个路径部分, 返回值是 <em>path</em> 和 <em>paths</em> 的所有成员的拼接, 其中每个非空部分后面都紧跟一个目录分隔符, 最后一个部分除外<ul><li>如果最后一个部分为空, 则结果将以分隔符结尾</li><li>如果某个部分为绝对路径, 则之前的所有部分会被 <strong>丢弃</strong>, 然后从绝对路径部分重新开始继续拼接</li></ul></li><li><code>os.path.splitex(path)</code>: 将路径名称拆分为 <code>(root, ext)</code> 对, 使得 <code>root + ext = path</code>, 并且扩展名为空或以句点打头并最多只包含一个句点</li><li><code>os.path.splitdrive(path)</code>: 将路径拆分为一对, 即 <code>(drive, tail)</code>, 使得 <code>drive + tial == path</code>, 其中 <em>drive</em> 是持载点或空字符串<ul><li>如果路径 path 包含盘符, 则 drive 将包含冒号之前的所有内容包括冒号本身</li></ul></li><li><code>os.path.exists(path)</code>: 如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符, 返回 <code>True</code></li><li><code>os.path.isdir(path)</code>: 判断 path 是否为目录</li><li><code>os.path.isfile(path)</code>: 判断 path 是否为文件</li></ul><h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><ul><li><code>os.getenv(name)</code>: 获取系统环境变量值</li><li><code>os.listdir(path)</code>: 返回路径下的所有文件与目录名 </li><li><code>os.remove(file_path)</code>: 删除<strong>文件</strong> (不能是目录)</li><li><code>os.rmdir(dir_path)</code>: 删除<strong>空</strong>目录<ul><li><code>os.rmdirs(dir_path)</code>: <strong>递归</strong>删除<strong>空</strong>目录</li></ul></li></ul><h1 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h1><p>Python 进度条: <code>from tqdm import tqdm</code></p><ul><li><code>desc</code>: 进度条描述</li><li><code>initial</code>: 进度条的起始值 (默认为 0) (不是偏移量, 只是显示值的起点)</li></ul><p><strong>参考:</strong></p><ul><li><a href="https://www.zhihu.com/question/420057177/answer/2268739686">python的tqdm可以调整进度条的颜色吗. 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/163613814">周兵. python进度条库tqdm详解. 知乎</a></li></ul>]]></content>
    
    
    <summary type="html">Python 常用库使用笔记</summary>
    
    
    
    <category term="Coding" scheme="https://zonglin-tian.github.io/categories/Coding/"/>
    
    
    <category term="Python" scheme="https://zonglin-tian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>科研基础知识</title>
    <link href="https://zonglin-tian.github.io/2025/08/11/Basic-Knowledge/"/>
    <id>https://zonglin-tian.github.io/2025/08/11/Basic-Knowledge/</id>
    <published>2025-08-11T02:50:21.000Z</published>
    <updated>2025-08-11T03:06:28.894Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三线性插值-Trilinear-Interpolation"><a href="#三线性插值-Trilinear-Interpolation" class="headerlink" title="三线性插值 (Trilinear Interpolation)"></a>三线性插值 (Trilinear Interpolation)</h1><p>用于三维空间数据插值, 通过对三个维度 $(x, y, z)$ 进行线性插值, 估算出目标点的值, 是双线性插值 (Bilinear Interpolation) 在三维空间的拓展</p><ul><li>核心思想: 在三维空间的 8 个邻近点 (立方体的顶点) 之间进行加权平均, 计算目标点的值</li><li>步骤: <ul><li>找到目标点所在的立方体单元 (8 个顶点)</li><li>在 $X$ 方向线性插值 4 次 (得到 4 个中间值)</li><li>在 $Y$ 方向线性插值 2 次 (得到 2 个中间值)</li><li>在 $Z$ 方向线性插值 1 次 (得到最终目标值)</li></ul></li><li>权重因子: $\alpha &#x3D; u - \lfloor u \rfloor$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Research" scheme="https://zonglin-tian.github.io/categories/Research/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 磁盘管理</title>
    <link href="https://zonglin-tian.github.io/udisk/"/>
    <id>https://zonglin-tian.github.io/udisk/</id>
    <published>2025-07-10T11:10:48.000Z</published>
    <updated>2025-07-11T03:38:25.667Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><ul><li><code>fdisk -l</code>: 查看分区情况<ul><li><code>fdisk -l /dev/sda</code>: 查看磁盘 sda 的分区</li></ul></li><li><code>df -h</code>: 查看分区使用与挂载情况 (<code>lsblk</code>)</li></ul><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p><code>fdisk</code> (format disk) 磁盘分区管理的命令行工具, 适用于 MBR (MS-DOS) 和 GPT 分区表, 可以创建, 删除, 调整分区, 并修改分区类型: <code>sudo fdisk [选项] &lt;磁盘设备&gt;</code></p><ul><li><code>-l</code>: 列出所有磁盘分区表 (不进入交互模式)</li><li><code>fdik &lt;磁盘设备&gt;</code>: 进入交互模式<ul><li>常用: <strong>n 创建分区 → 根据情况输入 (大多数时候按回车选默认值) → p 打印分区, 确认无误 → w 保存设置</strong></li><li><strong>m 展示帮助</strong></li><li>F 展示磁盘剩余未分区空间</li><li>n 增加一个新分区</li><li>d 删除分区</li><li>p 打印分区情况</li><li>t修改分区类型 (Linux&#x3D;83, swap&#x3D;82, NTFS&#x3D;7)</li><li>w 保存并退出</li><li>q 不保存退出</li></ul></li><li><code>partprobe</code>: 使修改生效</li></ul><h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li><code>umount [挂载点或设备路径]</code>: 卸载已挂载的文件系统<ul><li><code>-f</code>: 强制卸载 </li><li><code>-v</code>: 显示详细操作信息</li></ul></li><li><code>mount [选项] [设备] [挂载点]</code>: 将存储设备挂载到文件系统的某个目录 (<strong>挂载点</strong>), 从而访问其中的数据<ul><li><code>设备</code>: 磁盘分区 (<code>/dev/sda1</code>), UUID, LABEL 或网络存储</li><li><code>挂载点</code>: 一个已经存在的目录</li><li><strong><code>findmnt</code>&#x2F;<code>mount</code>: 显示所有挂载点</strong></li><li><code>-t &lt;文件类型系统&gt;</code>: 指定文件系统类型</li><li><code>-o &lt;挂载选项&gt;</code>: 指定挂载选项</li><li><strong><code>-a</code>: 挂载 <code>/etc/fstab</code> 中所有未挂载的设备 (测试 <code>fstab</code> 配置是否正确)</strong></li><li><code>-v</code>: 显示详细挂载信息</li><li><code>-l</code>: 显示已挂载设备的 LABEL</li><li><code>-r</code>: 以只读模式挂载</li><li><code>-w</code>: 以读写模式挂载 (<strong>默认</strong>)</li></ul></li><li><code>sudo blkid</code>: 查看 UUID 和 LABEL (blok id)</li></ul><h2 id="etc-fstab-文件"><a href="#etc-fstab-文件" class="headerlink" title="&#x2F;etc&#x2F;fstab 文件"></a>&#x2F;etc&#x2F;fstab 文件</h2><p><code>/etc/fstab</code> (File System Table) 用于定义系统启动时自动挂载的文件系统和存储设备, 包含了系统需要挂载的所有分区, 网络共享和特殊文件系统的信息</p><p>文件由若干行组成, 每行定义一个挂载点, 字段之间使用单个制表符 (Tab) 分隔, <code>#</code> 表示注释, <strong>每行必须包含 6 个字段: <code>&lt;设备标识&gt; &lt;挂载点&gt; &lt;文件系统类型&gt; &lt;挂载选项&gt; &lt;dump 备份标志&gt; &lt;fsck 检查顺序&gt;</code></strong></p><ul><li>设备标识: 设备路径 (<code>/dev/sda1</code>), <code>UUID=</code> (<strong>更可靠</strong>), <code>LABEL=</code></li><li>挂载点: 文件系统用于挂载的目录路径 (<code>/</code>, <code>/home</code>, <code>/mnt/data</code>)</li><li>文件系统类型: <code>ext4</code> (Linux 常用), <code>xfs</code>, <code>btrfs</code>, <code>vfat</code> (FAT32), <code>ntfs</code> (Windows NTFS), <code>swap</code> (交换分区), <code>nfs</code> (网络文件系统), <code>tmpfs</code> (临时文件系统)</li><li>挂载选项: 多个选项用逗号分隔<ul><li><code>defaults</code>: (rw, suid, dev, exec, auto, nouser, async)</li><li><code>ro/rw</code>: 只读&#x2F;读写</li><li><code>noauto</code>: 启动时不自动挂载</li><li><code>user</code>: 允许普通用户挂载</li><li><strong><code>nofail</code>: 设备不存在时不报错</strong></li><li><code>exec/noexec</code>: 允许&#x2F;禁止执行二进制文件</li><li><code>suid/nosuid</code>: 允许&#x2F;禁止 SUID 和 SGID 位</li><li><code>_netdev</code>: 网络设备, 等待网络就绪后再挂载</li></ul></li><li>dump 备份标志: 0 (不备份), 1 (备份)</li><li>fsck 检查顺序: 0 (不检查), 1 (优先检查, <strong>根分区应为 1</strong>), 2 (次要检查)</li></ul><h1 id="home-重挂载或扩容"><a href="#home-重挂载或扩容" class="headerlink" title="home 重挂载或扩容"></a>home 重挂载或扩容</h1><p><strong>前提: 被扩容设备必须是 “起始” 分区</strong><br><strong>备份设备: 被扩容设备或者另外的设备</strong></p><ol><li>备份 <code>/home</code> 的数据到备份设备</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /media/home<br>sudo mount /back_up_device /media/home<br>sudo rsync -azXS --progress --partial /home/ /media/home/<br></code></pre></td></tr></table></figure><ol start="2"><li><code>/home</code> 重新挂载</li></ol><ul><li>卸载<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo umount /home<br><span class="hljs-comment"># 显示占用进程的 PID 和用户</span><br><span class="hljs-comment"># sudo fuser -vm /home</span><br><span class="hljs-comment"># 发送 SIGKILL 终止所有占用进程</span><br><span class="hljs-comment"># 强制解除占用</span><br>sudo umount -f /home<br></code></pre></td></tr></table></figure></li><li>挂载: 以防无法正常重启<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/fstab<br><span class="hljs-comment"># 将 /home 挂载到 /back_up_device</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>删除原 <code>/home</code> 挂载分区 (<code>/dev/sda2</code>)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk /dev/sda<br><span class="hljs-comment"># d → 2 → w</span><br></code></pre></td></tr></table></figure><ol start="4"><li>被扩容配备扩容 (<code>/dev/sda1</code>)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk /dev/sda<br><span class="hljs-comment"># 通过 p 查看 sda1 的起始扇区并记住</span><br><span class="hljs-comment"># d → 1 → n → 1 → ... → w</span><br><span class="hljs-comment"># 务必保证起始扇区一致</span><br><span class="hljs-comment"># 检查文件系统</span><br>sudo e2fsck -f /dev/sda1<br><span class="hljs-comment"># 调整 ext4 文件系统大小</span><br>sudo resize2fs /dev/sda1<br></code></pre></td></tr></table></figure><ol start="5"><li>重新挂载 <code>/home</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/fstab<br><span class="hljs-comment"># 将 /home 挂载到 /dev/sda1</span><br>sudo mount -a<br><span class="hljs-comment"># 若有必要, 复制备份的 /home 数据</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Ubuntu 磁盘管理常用命令</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zonglin-tian.github.io/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式与通配符</title>
    <link href="https://zonglin-tian.github.io/regex/"/>
    <id>https://zonglin-tian.github.io/regex/</id>
    <published>2025-07-02T13:01:42.000Z</published>
    <updated>2025-08-11T00:55:48.428Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Shell-引号解析"><a href="#Shell-引号解析" class="headerlink" title="Shell 引号解析"></a>Shell 引号解析</h1><p><strong>理解:</strong></p><ul><li>单引号: 完全不管, 原样输出<ul><li><strong>固定</strong>正则表达式</li></ul></li><li>双引号: 稍微加工, 变量替换, 扩展 <code>$</code>, <code>`</code>, <strong><code>\</code> 转义字符 (<code>$`&quot;\</code>)</strong>, <code>$()</code> , 保护特殊字符 (<code>空格*?单引号</code>)<ul><li>含<strong>变量</strong>的正则表达式</li></ul></li><li>不加引号 (<strong>Shell 截胡</strong>): 过度加工, 替换变量, 拆分空格, 将特殊字符 (<code>*?</code>) 当成通配符匹配文件<ul><li><code>[[ &quot;string&quot; =~ regex  ]]</code> 右侧的 <code>regex</code> 不能加引号, 否则正则符号 (<code>.*</code>) 会变成普通字符</li><li>通配符, 重定向, 管道符</li></ul></li></ul><p><strong>口决:</strong></p><ul><li>有变量? 用双引号</li><li><strong>没变量? 用单引号</strong></li><li><code>[[ =~ ]]</code> 条件测试? 变量别加引号</li><li><strong>永远别完全不加引号</strong></li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>正则表达式 (Regular Expressions)</strong> 用于<strong>文本内容匹配</strong> (如搜索, 替换字符串), 常见于 <code>grep</code>, <code>sed</code>, <code>awk</code>, <code>vim</code> 等命令</p><ul><li>普通字符: 字母, 数字, 符号匹配本身</li><li><strong>元字符</strong>: 具有特殊含义, 用于构造匹配规则</li></ul><h2 id="基础正则-BRE"><a href="#基础正则-BRE" class="headerlink" title="基础正则 (BRE)"></a>基础正则 (BRE)</h2><ul><li><code>\</code>: 转义符, 匹配特殊字符本身 (<code>&#123;</code>, <code>&#125;</code>, <code>+</code>)</li><li><code>.</code>: 任意单个字符 (除换行符)</li><li>字符集与字符范围<ul><li><code>[]</code>: 匹配括号内任意一个字符 (<code>[0-9]</code>, <code>[a-zA-Z]</code>)</li><li><code>[^]</code> (否定字符集): 匹配不在括号内的字符</li><li>当 <code>-</code> 出现在开头或结尾, <code>^</code> 出现在中间时, 为普通字符</li><li><code>\d</code>: 匹配数字 (<code>\d+</code> 连续数字)</li><li><code>\w</code>: 匹配单词字符 (字母, 数字, 下划线)</li></ul></li><li>边界符<ul><li><code>^</code>: 匹配字符串开始</li><li><code>$</code>: 匹配字符串结束</li></ul></li><li>量词 (重复符号): 用于指定前一个字符或分组重复出现的次数<ul><li><code>?</code>: 前一个字符 0 次或 1 次</li><li><code>*</code>: 前一个字符 0 次或多次 (不包括换行)<ul><li><strong><code>.*</code>: 匹配任意数量字符 (包括零个)</strong></li><li><code>^a.*z$</code>: 匹配以 a 开头, 以 z 结尾的任意字符串 (中间可以是任意字符)</li></ul></li><li><code>+</code>: 前一个字符 1 次或多次</li><li><code>&#123;n,m&#125;</code>: 前一个字符 n 到 m 次<ul><li><code>&#123;n&#125;</code>: 恰好 n 次</li><li><code>&#123;n,&#125;</code>: 至少 n 次</li></ul></li></ul></li><li><code>(pattern)</code>: 捕获分组</li><li><code>(a|b)</code>: 匹配 <code>a</code> 或 <code>b</code></li></ul><h2 id="扩展正则-ERE"><a href="#扩展正则-ERE" class="headerlink" title="扩展正则 (ERE)"></a>扩展正则 (ERE)</h2><ul><li>元字符无需转义, 易读</li></ul><h2 id="Perl-风格正则-PCRE"><a href="#Perl-风格正则-PCRE" class="headerlink" title="Perl 风格正则 (PCRE)"></a>Perl 风格正则 (PCRE)</h2><ul><li>由 Perl 语言发展而来, 功能最强大, 元字符无需转义</li><li>支持命令:<ul><li><code>grep -P</code></li></ul></li><li><code>\d</code>: 匹配数字</li><li><code>\D</code>: 非数字</li><li><code>\s</code>: 空白字符</li><li><code>\S</code>: 非空白字符</li><li><code>\w</code>: 单词字符 (字母, 数字, 下划线)</li><li><code>\W</code>: 非单词字符 (标点符号, 空格)</li><li><code>\b</code>: 匹配单词边界 (<code>grep -P &quot;\bcat\b&quot;</code> → <code>cat</code>)</li><li>逻辑: <code>|</code> (或)</li></ul><h2 id="支持命令"><a href="#支持命令" class="headerlink" title="支持命令"></a>支持命令</h2><ul><li><code>grep</code>: 文本搜索, 默认使用基础正则<ul><li><code>grep -E</code> 或 <code>egrep</code>: 启用扩展正则</li></ul></li><li><code>sed</code>: 流编辑器, 文本替换&#x2F;处理, 默认使用基础正则<ul><li><code>sed -E</code>: 启用扩展正则</li></ul></li><li><code>awk</code>: 文本处理&#x2F;字段提取, 默认使用<strong>扩展正则</strong></li><li><code>find</code>: 文件查找<ul><li><code>-regex</code>: 使用<strong>扩展正则</strong></li><li><code>-name</code>: 使用<strong>通配符</strong></li></ul></li><li><code>vim</code>: 文本编辑器<ul><li><code>\m</code>: 基础正则</li><li><code>\v</code>: 扩展正则</li></ul></li><li><code>less</code>: 分页查看, 默认使用基础正则</li></ul><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p><strong>通配符 (Wildcards)</strong> 主要用于快速匹配<em><strong>文件名</strong></em>或<em><strong>目录名</strong></em>的特殊字符</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>区分大小写</li><li><code>*</code> 不匹配以 <code>.</code> 开头的隐藏文件 (需显式指定 <code>.*</code>)</li><li>通配符<strong>不需要加单引号</strong>, 加单引号表示禁用通配符, 即为普通字符</li><li>特殊字符需通过 <code>\</code> 转义: <code>^</code>, <code>~</code></li></ul><h2 id="基础通配符"><a href="#基础通配符" class="headerlink" title="基础通配符"></a>基础通配符</h2><ul><li><code>*</code>: 任意数量 (包括零个) 的任意字符<ul><li><code>*.txt</code>: 所有 <code>.txt</code> 文件</li></ul></li><li><code>?</code>: 单个任意字符<ul><li><code>file?.log</code>: <code>file1.log</code>, <code>file2.log</code></li></ul></li><li><code>[]</code>: 括号内任意<strong>一个</strong>字符或范围<ul><li><code>[0-9]</code>, <code>[a-z]</code>, <code>[abc]</code></li><li>扩展: <code>[^/!]</code> (取反)</li></ul></li><li><code>&#123;&#125;</code>: <strong>生成组合</strong> (非匹配, 用于展开)<ul><li><code>&#123;start..end&#125;</code>, <code>&#123;a,b,c&#125;</code> <strong>(不含空格)</strong></li></ul></li></ul><h2 id="zsh-扩展通配符"><a href="#zsh-扩展通配符" class="headerlink" title="zsh 扩展通配符"></a>zsh 扩展通配符</h2><ul><li>检查当前与通配符相关的设置: <code>setopt | grep glob</code> (若输出 <code>extendedglob</code> 表示已启用)</li><li>手动启用: <code>setopt extendedglob</code> (永久启用需写入 <code>~/.zshrc</code> 中)</li><li><code>^</code>: 排除模式 (取反)</li><li><code>~</code>: 排除特定模式<ul><li><code>*.txt~backup*</code>: 匹配 <code>.txt</code> 文件但排除含 <code>backup</code> 的文件</li></ul></li><li><code>(x|y)</code>: 匹配 <code>x</code> 或 <code>y</code></li></ul>]]></content>
    
    
    <summary type="html">常用正则表达式与通配符</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zonglin-tian.github.io/categories/Ubuntu/"/>
    
    
    <category term="Writing..." scheme="https://zonglin-tian.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>常用文件格式</title>
    <link href="https://zonglin-tian.github.io/format/"/>
    <id>https://zonglin-tian.github.io/format/</id>
    <published>2025-06-21T02:37:02.000Z</published>
    <updated>2025-06-21T03:17:20.696Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p><code>JSON</code> (JavaScript Object Notation): 轻量级数据交换格式, 具有简洁, 易读的文本结构 (<code>.json</code>)</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ul><li>键值对: 数据以 <code>key: value</code>的形式存储, 键必须是<strong>双引号包裹的字符串</strong></li><li>值的数据类型<ul><li>字符串: <code>&quot;name&quot;: &quot;Temm&quot;</code></li><li>数字: <code>&quot;Age&quot;: 3</code></li><li>布尔值: <code>&quot;is_student&quot;: true</code></li><li>空值: <code>&quot;address&quot;: null</code></li><li>对象 (嵌套): <code>&quot;university&quot;: &#123;&quot;name&quot;: &quot;BNU&quot;&#125;</code></li><li>数组: <code>&quot;scores&quot;: [90, 85, 77]</code></li></ul></li></ul><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><ul><li>根元素必须是对象 <code>&#123;&#125;</code> 或数组 <code>[]</code></li><li>引号必须用双引号: 单引号或无引号无效</li><li>逗号分隔: 键值对之间用逗号分隔, 但<strong>末尾不能有逗号</strong></li><li>无注释: 不支持标准注释 <code>//</code>, <code>/**/</code> </li><li>在线校验: <a href="https://jsonlint.com/">JSONLint</a></li></ul><h2 id="衍生格式"><a href="#衍生格式" class="headerlink" title="衍生格式"></a>衍生格式</h2><h3 id="JSONC-JSON-with-Comments"><a href="#JSONC-JSON-with-Comments" class="headerlink" title="JSONC (JSON with Comments)"></a>JSONC (JSON with Comments)</h3><ul><li>扩展名: <code>.jsonc</code></li><li>特点:<ul><li>支持 <code>//</code> 单行注释和 <code>/**/</code> 多行注释</li><li>保留 JSON 的严格数据结构, 仅增加注释功能</li></ul></li></ul><h3 id="JSON5-更人性化的-JSON"><a href="#JSON5-更人性化的-JSON" class="headerlink" title="JSON5 (更人性化的 JSON)"></a>JSON5 (更人性化的 JSON)</h3><ul><li>扩展名: <code>.json5</code></li><li>特点:<ul><li>支持注释, 尾随逗号, 单引号字符串, 无引号键名, 十六进制数字等</li><li>目标是更易手写和维护</li><li><a href="https://json5.org/">官方库</a></li></ul></li></ul><h3 id="JSONL-JSON-Lines"><a href="#JSONL-JSON-Lines" class="headerlink" title="JSONL (JSON Lines)"></a>JSONL (JSON Lines)</h3><ul><li>扩展名: <code>.jsonl</code></li><li>特点: <ul><li>每行是一个独立的 JSON 对象, 适合流式处理或日志文件</li><li><strong>无需根数组或对象包裹</strong></li></ul></li></ul><h1 id="YAML-yml-yaml"><a href="#YAML-yml-yaml" class="headerlink" title="YAML (.yml&#x2F;.yaml)"></a>YAML (.yml&#x2F;.yaml)</h1><h1 id="INI-ini"><a href="#INI-ini" class="headerlink" title="INI (.ini)"></a>INI (.ini)</h1><h1 id="CSV-csv"><a href="#CSV-csv" class="headerlink" title="CSV (.csv)"></a>CSV (.csv)</h1>]]></content>
    
    
    <summary type="html">常用文件格式结构与语法</summary>
    
    
    
    <category term="Others" scheme="https://zonglin-tian.github.io/categories/Others/"/>
    
    
    <category term="Writing..." scheme="https://zonglin-tian.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>Debugging...</title>
    <link href="https://zonglin-tian.github.io/debug/"/>
    <id>https://zonglin-tian.github.io/debug/</id>
    <published>2025-06-12T05:14:55.000Z</published>
    <updated>2025-06-23T03:27:48.017Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绪"><a href="#绪" class="headerlink" title="绪"></a>绪</h1><div class="note note-warning">            <p>Troubleshooting any problem without the error log is like driving with your eyes closed. (在没有错误日志的情况下诊断任何问题无异于闭眼开车)</p>          </div><h1 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h1><ul><li>解决办法:<ul><li>数据归一化</li><li>限制数据范围: <code>torch.clamp()</code></li><li>降低学习率或添加梯度裁剪 (<code>torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=specified_value)</code>)</li></ul></li><li>调试命令: <strong><code>torch.isnan()</code>, <code>torch.where()</code></strong><ul><li>自动检测反向传播过程中梯度是否存在 <code>NaN</code> 或 <code>inf</code>, 当检测到异常时会打印出该异常的原始前向传播操作并抛出 <em>RuntimeError</em><ul><li><strong>局部 (精细调试): <code>with torch.autograd.detect_anomaly(check_nan=True):</code></strong></li><li>全局: <code>torch.autograd.set_detect_anomaly(check_nan=True)</code></li></ul></li><li>检查是否含有 <code>NaN</code>: <code>torch.isnan(tensor).any()</code></li><li>统计 <code>NaN</code> 的数量: <code>torch.isnan(tensor).sum().item()</code></li><li>定位 <code>NaN</code> 的位置: <code>torch.where(torch.isnan(tensor))</code></li><li>替换 <code>NaN</code> 为特定值: <code>torch.nan_to_num(tensor, nan=specified_value)</code></li><li>过滤非 <code>NaN</code> 值: <code>valid_values = tensor[~torch.isnan(tensor)]</code></li><li>检查梯度中的 <code>NaN</code>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> model.named_parameters():<br>    <span class="hljs-keyword">if</span> param.grad <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> torch.isnan(param.grad).<span class="hljs-built_in">any</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;梯度 NaN 出现在参数: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">写代码 5 分钟, 调 BUG 两小时</summary>
    
    
    
    <category term="Coding" scheme="https://zonglin-tian.github.io/categories/Coding/"/>
    
    
    <category term="Writing..." scheme="https://zonglin-tian.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 用户管理</title>
    <link href="https://zonglin-tian.github.io/uuser/"/>
    <id>https://zonglin-tian.github.io/uuser/</id>
    <published>2025-06-06T06:47:25.000Z</published>
    <updated>2025-06-14T02:44:18.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="高频命令"><a href="#高频命令" class="headerlink" title="高频命令"></a>高频命令</h1><ul><li>创建用户: <code>adduser new_user_name</code></li><li>修改用户密码: <code>passwd user_name</code></li><li>删除用户并移除其工作目录: <code>deluser --remove-home user_name</code></li><li>切换用户并加载其环境变量: <code>su - user_name</code></li><li>查看用户所属组: <code>id user_name</code> or <code>groups user_name</code></li><li>编辑 <code>sudo</code> 文件: <code>sudo visudo</code></li><li>将用户添加到 <code>sudo</code> 组: <code>usermod -aG sudo user_name</code></li></ul><h1 id="查看登陆信息"><a href="#查看登陆信息" class="headerlink" title="查看登陆信息"></a>查看登陆信息</h1><ul><li>查看登陆用户 (详细程度 ↑): <code>whoami</code> (当前用户) → <code>users</code> (用户名列表) → <code>who</code> (登陆时间 &amp; 来源 IP) → <strong><code>w</code></strong> (空闲时间 &amp; 当前进程) → <code>last</code> (登陆历史)  </li><li>查看用户信息 (id 与组): <code>id user_name</code></li><li>查看所有用户: <code>grep -P &quot;bash|zsh&quot; /etc/passwd [| cut -d: -f1]</code></li></ul><h1 id="切换用户-su"><a href="#切换用户-su" class="headerlink" title="切换用户 (su)"></a>切换用户 (su)</h1><p><code>su [options] [-] user_name [parameters]</code></p><ul><li><code>-</code> 或 <code>-l</code>: 加载相应的环境变量 (<strong>推荐</strong>), 后面不加用户名表示切换到 <em>root</em></li><li><code>-c cmd</code>: 以特定用户身份执行命令</li><li><code>-s SHELL</code>: 指定 <em>shell</em></li><li><code>-g group_name</code>: 指定主组</li><li><code>-p</code>: 不重置环境变量 (不推荐)</li></ul><p><strong>注:</strong> 优先使用 <code>sudo</code> 执行命令, 而不是切换到相应用户</p><h1 id="创建用户-adduser"><a href="#创建用户-adduser" class="headerlink" title="创建用户 (adduser)"></a>创建用户 (adduser)</h1><ul><li>创建: <code>adduser new_user_name</code></li><li>测试用户<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到新用户, 确保帐户正常</span><br>su -u new_user_name<br><span class="hljs-comment"># 验证当前用户</span><br><span class="hljs-built_in">whoami</span><br><span class="hljs-comment"># 系统中是否存在</span><br><span class="hljs-built_in">id</span> new_user_name<br><span class="hljs-comment"># 退出新用户</span><br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="修改用户-usermod"><a href="#修改用户-usermod" class="headerlink" title="修改用户 (usermod)"></a>修改用户 (usermod)</h1><ul><li>更改 shell: <code>usermod -s /bin/zsh user_name</code></li><li>sudo 权限<ul><li>添加到 sudo 组: <code>usermod -aG sudo user_name</code></li><li>从 sudo 组中删除: <code>deluser user_name sudo</code></li></ul></li></ul><h1 id="删除用户-deluser"><a href="#删除用户-deluser" class="headerlink" title="删除用户 (deluser)"></a>删除用户 (deluser)</h1><ul><li>查找用户的文件 (可在删除前后查看与验证)<ul><li>用户名: <code>find / -user user_name -ls</code></li><li>id: <code>find / -uid user_id -ls</code></li></ul></li><li>删除用户并移除其工作目录: <code>deluser --remove-home user_name</code><ul><li>仅删除用户: <code>deluser user_name</code></li></ul></li><li>查找文件系统中与任何用户都没有关联的文件: <code>find / -nouser -ls</code></li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><ul><li><code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>etc/group</code>: 创建新用户时, 增加相应条目, 字段间用冒号分隔<ul><li><code>/etc/passwd</code>: 帐户信息, 用户登陆名:x(密码):用户ID:组ID:用户信息:用户目录:用户登陆 shell</li><li><code>/etc/group</code>: 组信息, 组名:x(密码):组ID:用户列表 <em>(默认情况下, 每个用户都被添加到自己的组中)</em></li></ul></li><li><code>/etc/adduser.conf</code>, <code>/etc/login.defs</code>: <code>adduser</code> 创建新用户时的默认选项</li><li><code>/etc/skel/</code>: 创建新用户时, 此<strong>文件夹</strong>下的所有文件将被复制到新用户家目录下, 通常包括登陆和应用程序启动脚本</li></ul><h1 id="sudo-权限管理"><a href="#sudo-权限管理" class="headerlink" title="sudo 权限管理"></a>sudo 权限管理</h1><h2 id="usermod-添加用户到-sudo-组"><a href="#usermod-添加用户到-sudo-组" class="headerlink" title="usermod 添加用户到 sudo 组"></a>usermod 添加用户到 sudo 组</h2><ul><li>操作: <code>usermod -aG sudo user_name</code></li><li>验证 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 是否添加成功</span><br><span class="hljs-built_in">groups</span> user_name<br><span class="hljs-comment"># 切换到用户</span><br>su - user_name<br><span class="hljs-comment"># 如果输入密码后能成功执行, 配置正确</span><br>sudo apt update<br></code></pre></td></tr></table></figure></li></ul><h2 id="编辑-etc-sudoers-文件"><a href="#编辑-etc-sudoers-文件" class="headerlink" title="编辑 &#x2F;etc&#x2F;sudoers 文件"></a>编辑 &#x2F;etc&#x2F;sudoers 文件</h2><div class="note note-warning">            <ul><li>永远不要直接编辑 <strong>&#x2F;etc&#x2F;sudoers</strong> 文件, 语法错误可能导致所有 sudo 访问被锁定</li><li>使用 <code>visudo</code> 命令编辑, 其会检查语法错误 (<code>visudo -c</code>)</li><li>尽量使用用户组而非单个用户</li><li>限制权限到最小必要范围</li><li>查看日志文件: <code>sudo tail -f /var/log/auth.log</code></li></ul>          </div><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><code>用户/用户组 主机=(目标用户[:组]) [NOPASSWD:]命令</code></p><ul><li>用户: <code>user_name</code></li><li>用户组: <code>%group_name</code> (以 <code>%</code> 开头)</li><li>主机 (从何处登陆): 通常设置为 <code>ALL</code> 表示所有主机, 可以指定主机名</li><li>目标用户 (可以哪些用户身份运行命令): <code>(ALL)</code> 表示任何用户, <code>(root)</code> 表示 <em>root</em></li><li>组 (通常不需指定): 指定目标组, 可选, 默认使用目标用户的主组<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># (ALL)</span><br>sudo -u user_name <span class="hljs-built_in">id</span>  <span class="hljs-comment"># 用户=user_name, 组=user_name 的主组</span><br><span class="hljs-comment"># (ALL:ALL)</span><br><span class="hljs-comment"># 以指定用户及组运行命令</span><br>sudo -u user_name -g docker <span class="hljs-built_in">id</span>  <span class="hljs-comment"># 用户=user_name, 组=docker</span><br></code></pre></td></tr></table></figure></li><li>NOPASSWD: 允许无密码执行</li><li>命令 (允许执行命令列表, 以<strong>逗号</strong>分隔): 可以是完整路径 <code>/usr/bin/apt</code>, 也可以是目录 <code>/usr/sbin/</code> (结尾含 <code>/</code>), <code>ALL</code> 表示所有命令, 命令前加 <code>!</code> 表示禁止执行该命令</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>特殊字符: 字段之间以<strong>空格</strong>或<strong>制表位</strong>分隔, 命令列表之间以<strong>逗号</strong>  (必须) 分隔, 其后<em>可选</em>加空格, 注释以 <code>#</code> 开头</li><li>别名: 定义用户别名 (<code>User_Alias</code>), 主机别名 (<code>Host_Alias</code>), 命令别名 (<code>Cmnd_Alias</code>) 等<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Sudoers">User_Alias ADMINS = user1, user2, %admin<br>Host_Alias SERVERS = server1, server2<br>Cmnd_Alias PKGMGMT = /usr/bin/apt, /usr/bin/dpkg<br></code></pre></td></tr></table></figure></li><li>全局默认选项: <code>Default</code> 开头<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Sudoers"># 重置环境变量<br>Defaults env_reset<br># 2小时内无需重复输入<br>Defaults timestamp_timeout=120<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">用户管理常用命令</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zonglin-tian.github.io/categories/Ubuntu/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 文本处理</title>
    <link href="https://zonglin-tian.github.io/utext/"/>
    <id>https://zonglin-tian.github.io/utext/</id>
    <published>2025-05-01T08:30:00.000Z</published>
    <updated>2025-08-11T03:27:09.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><code>grep</code>, <code>sed</code>, <code>awk</code> Linux 文本处理三剑客, <code>grep</code> 搜索专家, <code>sed</code> 编辑快手, <code>awk</code> 数据处理大师</li></ul><h1 id="grep-文本处理瑞士军刀"><a href="#grep-文本处理瑞士军刀" class="headerlink" title="grep 文本处理瑞士军刀"></a>grep 文本处理瑞士军刀</h1><p><code>grep</code>, Global Regular Expression Print (全局正则表达式打印), 强大的文本搜索工具: 通过<strong>正则表达式</strong>或简单字符串快速搜索文件或输入流中的匹配内容, 并返回结果</p><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><ul><li><code>i</code>: 忽略大小写</li><li><code>v</code>: 反向匹配</li><li><code>n</code>: 显示匹配行的行号</li><li><code>c</code>: 统计匹配行的行数</li><li><code>o</code>: 仅输出匹配的部分</li><li><code>r</code>: 递归搜索目录</li></ul><h1 id="sed-Stream-Editor-流编辑器"><a href="#sed-Stream-Editor-流编辑器" class="headerlink" title="sed (Stream Editor) 流编辑器"></a>sed (Stream Editor) 流编辑器</h1><p>强大的<em>非交互式</em>流编辑器, 主要用于 (逐行) 文本<strong>替换, 删除, 插入和转换</strong>, 支持<em>正则表达式</em>, 尤其适合批量处理文件或管道数据</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>应用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># PATH 变量内容各路径独占一行并排序</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span> | sed <span class="hljs-string">&#x27;s/:/\n/g&#x27;</span> | <span class="hljs-built_in">sort</span><br></code></pre></td></tr></table></figure></li><li>替换 (<code>s</code>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全局替换</span><br>sed <span class="hljs-string">&#x27;s/old/new/g&#x27;</span> file.txt<br><span class="hljs-comment"># 替换第 2 个</span><br>sed <span class="hljs-string">&#x27;s/old/new/2&#x27;</span> file.txt<br></code></pre></td></tr></table></figure></li><li>删除 (<code>d</code>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除第 3 行</span><br>sed <span class="hljs-string">&#x27;3d&#x27;</span> file.txt<br><span class="hljs-comment"># 删除第 3-5 行, 最后一行用 $ 表示</span><br>sed <span class="hljs-string">&#x27;1,5d&#x27;</span> file.txt<br><span class="hljs-comment"># 删除匹配 &quot;pattern&quot; 的行</span><br>sed <span class="hljs-string">&#x27;/pattern/d&#x27;</span> file.txt<br></code></pre></td></tr></table></figure></li><li>插入&#x2F;追加 (<code>i/a</code>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在第 2 行前插入</span><br>sed <span class="hljs-string">&#x27;2i\插入内容&#x27;</span> file.txt<br><span class="hljs-comment"># 在最后一行后追加</span><br>sed <span class="hljs-string">&#x27;$a\追加内容&#x27;</span> file.txt<br></code></pre></td></tr></table></figure></li><li>打印行 (<code>p &amp; n</code>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只打印 1-3 行</span><br>sed -n <span class="hljs-string">&#x27;1,3p&#x27;</span> file.txt<br><span class="hljs-comment"># 打印包含 &quot;pattern&quot; 的行</span><br>sed -n <span class="hljs-string">&#x27;/pattern/p&#x27;</span> file.log<br></code></pre></td></tr></table></figure></li><li>行号操作 (<code>=</code>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在每行前显示行号</span><br>sed <span class="hljs-string">&#x27;=&#x27;</span> file.txt<br><span class="hljs-comment"># 打印匹配行的行号</span><br>sed -n <span class="hljs-string">&#x27;/pattern/=&#x27;</span> file.txt<br></code></pre></td></tr></table></figure></li></ul><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><code>sed [选项] &#39;脚本命令&#39; 文件名</code></p><ul><li><code>脚本命令</code>: 指定要执行的操作 (替换, 删除)</li><li><code>文件名</code>: 可省略 (从管道读取输入)</li></ul><h2 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h2><ul><li><code>n</code>: 禁止默认输出</li><li><code>-e &#39;command&#39;</code>: 指定多个命令</li><li><strong><code>-i</code>: 直接修改文件 (谨慎, 建议通过 <code>-i.bak</code> 进行备份)</strong></li><li><code>-r</code>: 启用扩展正则表达式</li></ul><h1 id="awk-“奥克”-Aho-Weinberger-Kernighan"><a href="#awk-“奥克”-Aho-Weinberger-Kernighan" class="headerlink" title="awk “奥克” (Aho-Weinberger-Kernighan)"></a>awk “奥克” (<em>A</em>ho-<em>W</em>einberger-<em>K</em>ernighan)</h1><p>Linux 系统中强大的文本处理和<strong>数据提取</strong>工具, 以逐行处理<strong>结构化文本</strong> (如日志, CSV) 著称, 支持<em>字段切割</em>, <em>模式匹配</em>, <em>数学运算</em>等复杂操作</p><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>提取指定列<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印第 1 和第 3 列 (空格分隔)</span><br>awk <span class="hljs-string">&#x27;&#123;print $3, $3&#125;&#x27;</span> file.txt<br><span class="hljs-comment"># 以 `:` 分割, 打印用户名和家目录</span><br>awk -F<span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print $1, $6&#125;&#x27;</span> /etc/passwd<br></code></pre></td></tr></table></figure></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>字段自动切割: 默认按<strong>空格或制表符</strong>分割每行, $1, $2…表示第 1, 2 列</li><li>模式-动作模型: <code>模式 &#123;动作&#125;</code> 仅当行匹配模式时执行动作</li><li>内置变量: <code>NR</code> 当前行号, <code>NF</code> 当前行的字段数, <code>RS</code> 行分隔符, <code>FS</code> 输入字段分隔符, <code>OFS</code> 输出字段分隔符, <code>$0</code> 整行内容, <code>$1~$n</code> 第 1 列到第 n 列的内容, <code>FILENAME</code> 当前处理的文件名</li><li>数学计算: <code>+, -, /, *, %</code></li></ul><h2 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h2><p><code>awk &#39;模式 &#123;动作&#125;&#39; 文件名</code></p><ul><li>省略模式: 对所有行执行动作 (如 <code>awk &#39;&#123;print $1&#125;&#39; file</code>)</li><li>省略动作: 默认打印匹配行（如 <code>awk &#39;/error/&#39; file</code>)</li></ul><h2 id="基本选项"><a href="#基本选项" class="headerlink" title="基本选项"></a>基本选项</h2><ul><li><code>-v key=value</code>: 定义变量, 可用于内部使用</li><li><code>-F&#39;:&#39;</code>: 设置字段分隔符</li></ul><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><h2 id="文本查看与处理"><a href="#文本查看与处理" class="headerlink" title="文本查看与处理"></a>文本查看与处理</h2><ul><li><code>cat</code>: 查看文件内容</li><li><code>less</code> &#x2F; <code>more</code>: 分页查看文件内容 (相关命令与 <code>VIM</code> 相似)<ul><li><strong><code>less</code></strong> 功能更齐全 (双向翻页, 行号), <code>more</code> 功能简单 (快速查看)</li><li><code>less +F log.txt</code> (比 <code>tail -f</code> 更灵活): 实时跟踪查看日志</li></ul></li><li><code>wc</code> (Word Count): <strong>统计行数 (<code>l</code>)</strong>, 单词数 (<code>w</code>), 字节数 (<code>-c</code>), 字符数 (<code>m</code>), 最长行长度 (<code>L</code>)<ul><li><code>grep -o &#39;word&#39; file.txt | wc -l</code>: 统计匹配词的出现次数</li></ul></li><li><code>head</code> &#x2F; <code>tail</code> 查看文件开头或者结尾的若干行 (默认 10 行)<ul><li><code>tail -n 5 log.txt</code>: 实时查看日志的最后 5 行</li></ul></li></ul><h2 id="文本过滤与搜索"><a href="#文本过滤与搜索" class="headerlink" title="文本过滤与搜索"></a>文本过滤与搜索</h2><ul><li><p><code>tr</code> (translate): 字符替换 (转换) 与删除, 通常与管道符 <code>|</code> 结合使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除所有数字</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello 123&quot;</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&#x27;0-9&#x27;</span><br><span class="hljs-comment"># 删除非数字字符</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Phone: 123-456-7890&quot;</span> | <span class="hljs-built_in">tr</span> -<span class="hljs-built_in">cd</span> <span class="hljs-string">&#x27;[:digit:]&#x27;</span><br><span class="hljs-comment"># 替换制表符为空格</span><br><span class="hljs-built_in">cat</span> file.txt | <span class="hljs-built_in">tr</span> <span class="hljs-string">&#x27;\t&#x27;</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment"># 压缩连续空格为单个空格</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;too  many   spaces&quot;</span> | <span class="hljs-built_in">tr</span> -s <span class="hljs-string">&#x27; &#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>tr str1 str2</code>: 用 <code>str2</code>中的字符对应替换 <code>str1</code> 中的字符</li><li><code>tr -d str</code>: 删除 <code>str</code> 中的字符</li><li><code>tr -s str</code>: 压缩 <code>str</code> 中的重复字符</li><li><code>str</code> 的格式<ul><li><code>c</code>: 取补集</li><li><code>abc</code>: 枚举字符</li><li><code>a-z</code>&#x2F;<code>[0-9]</code>: 范围</li><li><code>\n</code>&#x2F;<code>\t</code>: 特殊字符</li><li>预定义字符类</li></ul></li><li>预定义字符类<ul><li><code>&#39;[:alnum:]&#39;</code>: 字母和数字</li><li><code>&#39;[:alpha:]&#39;</code>: 字母</li><li><code>&#39;[:digit:]&#39;</code>: 数字</li><li><code>&#39;[:lower:]&#39;</code>: 小写字母</li><li><code>&#39;[:upper:]&#39;</code>: 大写字母</li><li><code>&#39;[:space:]&#39;</code>: 空白字符</li><li><code>&#39;[:punct:]&#39;</code>: 标点符号</li></ul></li></ul></li><li><p><code>sort</code>: 对文本排序 (默认按字母)</p><ul><li><code>f</code>: 忽略大小写</li><li><code>r</code>: 降序</li><li><code>n</code>: 按数值排序</li><li>字段控制<ul><li><code>u</code>: 去除重复行</li><li><code>k</code>: 指定排序字段 (列数字) ← <code>-k3n</code></li><li><code>t</code>: 指定字段分隔符 (,&#x2F;:)</li></ul></li><li>输出控制<ul><li><code>o</code>: 将结果输出到指定文件</li><li><code>c</code>: 检查是否排序</li><li><code>m</code>: 合并已排序文件</li></ul></li></ul></li><li><p><code>uniq</code>: 检查和删除<strong>连续重复行</strong> (常与 <code>sort</code> 配合)</p><ul><li><code>c</code>: 显示重复的次数</li><li><code>d</code>: 只显示重复的行</li><li><code>D</code>: 显示所有重复的行</li><li><code>u</code>: 只显示不重复的行</li></ul></li></ul><h2 id="字符串处理与生成"><a href="#字符串处理与生成" class="headerlink" title="字符串处理与生成"></a>字符串处理与生成</h2><ul><li><code>xargs</code>: 将输入转换为命令行参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除所有 .pth 文件</span><br>find . -name <span class="hljs-string">&#x27;*.txt&#x27;</span> | xargs <span class="hljs-built_in">rm</span><br></code></pre></td></tr></table></figure></li><li><code>cut</code>: 文本字段&#x2F;字符提取 (<code>awk</code> 的简化版)<ul><li><code>d</code>: 指定字段分隔符 (<code>-d:</code>)</li><li><code>f</code>: 选择指定字段 (<code>-f1,3</code>)</li><li><code>c</code>: 按字符位置提取 (<code>-c1-5</code>)</li></ul></li><li><code>printf</code>: 格式化输出 (比 <code>echo</code> 更灵活)</li></ul><h2 id="流处理与脚本工具"><a href="#流处理与脚本工具" class="headerlink" title="流处理与脚本工具"></a>流处理与脚本工具</h2><ul><li><code>tee</code>: 同时输出到屏幕和文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l | <span class="hljs-built_in">tee</span> output.txt<br></code></pre></td></tr></table></figure></li><li><code>nl</code>: 为文本添加行号</li></ul>]]></content>
    
    
    <summary type="html">grep sed awk 用法</summary>
    
    
    
    <category term="Ubuntu" scheme="https://zonglin-tian.github.io/categories/Ubuntu/"/>
    
    
    <category term="Writing..." scheme="https://zonglin-tian.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>每天学习一个思维</title>
    <link href="https://zonglin-tian.github.io/2025/03/14/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%80%9D%E7%BB%B4/"/>
    <id>https://zonglin-tian.github.io/2025/03/14/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%80%9D%E7%BB%B4/</id>
    <published>2025-03-14T12:05:07.000Z</published>
    <updated>2025-03-29T12:21:55.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://space.bilibili.com/3546587456342714">B 站 UP 主: 无限进化的Doria</a></li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><ul><li>写情绪日记: 自觉, 理解 (动机), 转化</li></ul><h1 id="靠自学快速学会任何东西-先做个垃圾出来"><a href="#靠自学快速学会任何东西-先做个垃圾出来" class="headerlink" title="靠自学快速学会任何东西: 先做个垃圾出来"></a>靠自学快速学会任何东西: 先做个垃圾出来</h1><ul><li>无论学习任何东西, 都直接跳过是什么和为什么的阶段, 而直接从如何做开始</li><li>不是要学会了再去做, 而是要先去做了才能真正学会. 再烂的开始, 都会有反馈. 只要有反馈, 就有办法改进. 只要能够改进, 就有变废为宝的机会</li><li>知识让人渊博, 经验让人深刻. 站在原地空想就全是问题, 迈步向前去做就全是答案</li></ul><h1 id="做成任何事-准时出摊"><a href="#做成任何事-准时出摊" class="headerlink" title="做成任何事: 准时出摊"></a>做成任何事: 准时出摊</h1><ul><li>阻碍一个人做事的所有内耗和焦虑, 可归结于想要的太多, 而得到的太少, 即<span class="emp-style yellow">浮躁. 浮躁让人什么事都想做, 做什么事又都想立刻看到效果</li><li>焦虑的的原因之一在于欲望大于能力, 所以对抗焦虑的解药之一, 就是<span class="emp-style">保持耐心, 准时出摊.</span> 耐心不是意志力, 不是要让人忍受无趣, 承受痛苦, 咬牙坚持, 耐心的本质是基于对客观规律的认知, 然后顺应规律做事</li><li>关键尾部事件: 概率分布在尾部, 非常罕见极端的事件. 现实中, 往往低概率事件是影响最终结果的主要因素</li><li>我们的焦虑几乎都来自我们太渴望付出就立刻获得回报, 我们总相信存在短期速成的方法和逃避困难的捷径. 因为缺乏对于客观规律的认知, 所以我们总是急于求成. 一旦结果不如预期, 就开始焦虑内耗, 然后在自我怀疑中彻底放弃. 然而, <span class="emp-style yellow">世界的真相是我们的人生并不是随着付出的努力线性增长, 而是由几个关键节点瞬间拉动.</span> 但在此之前, 需要默默积累相当长的时间, 甚至蛰伏好多年, 然后某天突然等到那个关键尾部事件的降临, 从此人生上升到一个新的台阶. 所以, 当下一次焦虑来袭的时候, 告诉自己: <span class="emp-style">“是的, 有的阶段就是注定无法跨越的, 我无法一蹴而就.”</span> </li><li><strong>这个世界就是一个充满了随机性的无限游戏, 我们能做的只有每天准时出摊, 保持行动, 剩下的就是耐心等待, 把结果交给上帝手里的骰子.</strong> 这个规律是事物必经的发展过程, 不以人的意志为转移. 戒掉焦虑, <span class="emp-style">放下对于结果的执念, 对于付出的计算, 在过程中打磨做事的技能, 平淡的心态以及良好的习惯, 直到那个关键尾部事件奇迹一般地发生在你生命中.</span> 在外人看来简直是幸运女神的眷顾, 而只有你清楚, 其实<strong>真正的幸运女神就是那个心无旁骛持续行动的自己</strong></li></ul><h1 id="瞬间战胜拖延-停止捏造不存在的问题"><a href="#瞬间战胜拖延-停止捏造不存在的问题" class="headerlink" title="瞬间战胜拖延: 停止捏造不存在的问题"></a>瞬间战胜拖延: 停止捏造不存在的问题</h1><ul><li><p>造成拖延的根本原因不是懒惰, 而是恐惧. 因为真正懒惰的人对于自己的不作为是完全心安理得的, 过程中没有丝毫的纠结和痛苦. 而真正的拖延症患者, 一定会在过程中饱受焦虑的煎熬, 明知道一件事拖着对自己不好, 再拖也不得不做, 但就是没办法一咬牙赶紧做起来. 理性产生的动力和情绪引发的阻力同时存在, 内心两股力量在冲撞对抗. 就像踩着刹车, 又想加油前进, 结果就是轮胎在原地疯狂空转, 车子没往前挪一毫米, 油却耗尽了. 所以, 拖延症危害最大的地方, 就是一个人明明看起来毫无动弹, 但是内在的情绪和心力已经被消耗殆尽, 决策系统近乎瘫痪, 凡事犹豫不决, 做事拖泥带水, 从而导致整个人行动力和自信心的彻底丧失. </p></li><li><p>为什么明明是不得不做的事, 行为启动起来却如此困难? 因为<span class="emp-style red">我们总是过度思考, 然后预设困难, 进而潜意识中产生恐惧. 这种恐惧会变成隐形的内阻力, 像一个拴在我们脚上的巨大石块, 将我们牢牢困在原地, 动弹不得.</span> 对于我们不喜欢且不擅长的事情, 我们恐惧: </p><ul><li>过程中的漫长无聊</li><li>遇到困难时的焦虑无助</li><li>付出了但是没有结果的失望透顶</li><li>全力以赴却被人全盘否定的自我怀疑</li></ul><p>  这些恐惧长期存在于我们的潜意识当中, 形成了一种惯性思维, 我们甚至都很难察觉到这些恐惧本身. 一旦理性想要开启对于一件事的行动, 那些存储在潜意识当中的恐惧立刻扑面而来, 将所有的动力瞬间瓦解. 然后为了缓解理性上的矛盾和焦虑, 就给自己编出一大堆合理化借口:</p><ul><li>今天太累了</li><li>今天心情不好</li><li>今天天气不好</li></ul><p>  然后留下一句: <span class="emp-style yellow">实在不行, 明天再做吧.</span> 然而明天, 恐惧会再次卷土重来, 你还是会再次止步不前. </p></li><li><p>要从根源上摆脱拖延症, 就一定要:</p><ul><li>停止捏造不存在的问题</li><li>停止给自己预设困难</li><li>停止在想象中推演过程</li><li>停止幻想完美主义的结果</li><li>停止问题沿未发生就提前焦虑</li></ul></li><li><p>然而想要摆脱已经形成的思维定式异常困难, 所以最直接最有效的办法就是<span class="emp-style">不给潜意识制造恐惧的机会, 不思考, 直接行动.</span> 具体方法可以给自己设定一个<span class="emp-style">五分钟原则: 如果做一个事的时间只需要 5 分钟甚至更少, 那就不要进行任何思考, 直接立刻去做.</span> 因为在这种情况下, 任何思考都只是在耗损能量和心力. 对于那些 5 分钟之内就能完成的事情, 过分思考根本毫无意义, 只需要此刻立即行动. 一旦你开始尝试秉持这个原则去生活, 你的生活会瞬间变得充满秩序感, 那些让你不舒服的小事都会逐渐消失:</p><ul><li>你的沙发上不会再有堆积如山的衣服</li><li>你的水池里也不会再有满是油污的锅碗瓢盆</li><li>你的地板上不会再有随处可见的头发和灰尘</li><li>你的垃圾桶也总是套着新的垃圾袋, 没有任何异味</li></ul><p>  最重要的是, 这些因为迅速行动而得到的<strong>正反馈</strong>, 会逐渐改变你的思维习惯. 这些良好的感受, 会成为激励你对任何事情立即展开行动的强大动力. 因此, 你就能重新找回对于自己行为的掌控力, 从而彻底摆脱潜意识中恐惧的操纵. <strong>一旦你形成决定了就立刻去做的思维定式, 你就会变得朝气蓬勃, 积极快乐, 这就是一个人生命力的体现.</strong></p></li><li><p>对于那些周期更长, 过程更复杂的事情, 你同样需要简化思维, 快速决策. </p><ol><li>第一步, 审慎对待真实存在的风险, 谨慎决定到底是做, 还是不做; </li><li>第二步, 面对任何一项任务, 尽快结束思考阶段, 尽量做到当机立断, 放弃对于<span class="emp-style red">最短路径和完美结果的执着</span>, 找到<span class="emp-style">最小可行性闭环</span>, 降低行动门槛, 先迈出第一步; </li><li>第三步, 在具体执行过程中, 依然遵循<strong>五分钟原则</strong>, 减少无谓思考, <span class="emp-style">凡事先立刻开始做五分钟</span>.</li></ol></li><li><p>只要你能够真正去实践五分钟原则, 你就能克服拖延的毛病, 凡事做到当机立断, 迅速行动, 从此执行力爆棚. 这个世界上最可怕的东西, 是只存在我们想像中的鬼, 因为我们人类最擅长的事情就是<span class="emp-style red">自己吓自己.</span> 所以, <span class="emp-style">停止过度思考, 停止捏造不存在的问题, 用肉体的行动去控制精神的内耗.</span> 每个人都是由自己的行动力塑造的, <strong>在这一生里, 我们的任务不是把自己塑造成自己想象中应该成为的理想, 而是找出我们天生是谁, 然后一步步成为他.</strong> 愿你永远勇往直前, 所向披靡.</p></li></ul><h1 id="内心强大到不可战胜-提高人生容错率"><a href="#内心强大到不可战胜-提高人生容错率" class="headerlink" title="内心强大到不可战胜: 提高人生容错率"></a>内心强大到不可战胜: 提高人生容错率</h1><ul><li>强者和弱者最大的区别不在于能力的高低, 而在于对不确定性的耐受力. 强者将不确定性视为机会, 弱者将不确定性视为风险. 所以, 面对不确定性时, 强者只相信事物的规律, 在风险中分析机会; 弱者总沉溺自己的情绪, 在机会中不控制风险.</li><li>一个人之所以会陷入焦虑和内耗的负面情绪, 往往并非因为现实中的失败, <strong>而是内心被不确定的结果所扰动</strong>. 任何人面对未知都会产生本能的恐惧, 这种对于不确定性的恐惧会转化为对确定性的盲目依赖. 为了逃避不确定性带来的恐惧和不安, 很多人就会变得极端地厌恶风险. 由此, 所有决策都会以稳定和低风险为首要标准, 以此来获得内心的安全感和掌控感. 然而, 任何一个能够在现实中拿到大结果的人, 都能够在高度不确定的环境中, 解决开放性命题. </li><li>如果你要想成为真正的强者和高手, 就必须<strong>不断提升自己对于不确定性的耐受力.</strong> 一个人能够承受多大的不确定性, 不是由个人意志决定的, 而是由他的<strong>人生容错率</strong>决定的. 强者并非出于天性能够无视概率和风险, 而是通过充分的能力和资源, 构建更高的人生容错率, 从而让他们有更强大的底气, 更充分的认知, 以及更冗余的时间和空间, 去对冲未知的风险和失败的概率</li><li>普通人如何提升自己的人生容错率?<ul><li><strong>正确归因, 找回掌控感.</strong> 如何定义问题, 决定了如何解决问题. <span class="emp-style">将问题向内归因于自己可以通过行动控制和影响的范畴, 是提高容错率的第一步.</span> 向内归因的意思不是自我怪罪, 绝对不要把问题上升到对于自我的全盘否定. <strong>正确的归因是将问题视为暂时的, 可解的, 可充分发挥主观能动性的, 从而拿回对于局面的掌控感.</strong> 当你感觉自己面对任何问题, 有足够的认知找到解决方案, 有足够控制力降低负面影响和实际损失, 你的心力就会增强, 决心就会变大, 你就能控制住对于不确定性的恐惧, 从情绪中解脱而投入行动</li><li><strong>积累冗余, 对冲概率和风险.</strong> 针对自己不可控的概率和风险, 就需要有足够的冗余来进行对冲. 现实中任何一次尝试都需要承担相应的成本, 所以积累冗余的目的, 就是<strong>要让自己永远都有再来一次的机会和底气</strong>. 全方位积累自己的资金, 能力, 人脉等等, 一切能够给自己人生兜底的资源, 从而让自己拥有不下牌桌的资格</li><li><strong>撬动杠杆, 从失败中获益.</strong> 失败仅仅是个人主观的感受. 客观上来讲, 没有失败, 只有反馈. 你把结果当作失败, 它就会让你一蹶不振. 你把结果当作机会, 它就能让你浴火重生. 传统教育让我们对扣分有根深蒂固的恐惧, 所以总试图不废一兵一卒就完美通关. 然而, <strong>人生的本质是一场概率游戏, 胜利和失败都是常态, 都只是撬动成长的杠杆. 我们要做不是每分必争, 而是用试错的经验, 撬动关键分的胜率. 用局部的失败, 换取整个系统的胜利, 而这就是反脆弱的精髓.</strong> 我们试图创造秩序, 结果往往是被混乱反噬. 我们总喜欢寻求稳定, 结果却往往被风险摧毁. <span class="emp-style">一个人变强的第一步, 就是接受命运的无常, 人生的波折, 生活的难测.</span> 挫折和失败躲不掉, 避不开, 绕不过. 然而, 任何杀不死你的, 终将使你变得更强大</li></ul></li><li>当你逐步为自己的人生, 创造出更高的容错率, 你就能够在波动, 随机, 混乱, 压力, 风险, 和不确定性下像荒原中的火苗一样, 星火燎原, 所向披靡</li></ul><h1 id="彻底戒掉成瘾行为-停止一边上瘾-一边厌恶"><a href="#彻底戒掉成瘾行为-停止一边上瘾-一边厌恶" class="headerlink" title="彻底戒掉成瘾行为: 停止一边上瘾, 一边厌恶"></a>彻底戒掉成瘾行为: 停止一边上瘾, 一边厌恶</h1><ul><li>毁掉一个人最快的方式, 就是<strong>一边上瘾, 一边厌恶.</strong> 对一些事情强迫性上瘾, 沉溺于刷短视频, 香烟酒精, 暴饮暴食, 看网络小说, 报复性熬夜等等. 明明在做这些事的过程中, 其实也并没有感到多快乐, 甚至明知道对自己有害, 但就是无法控制自己停下来. 就算好不容易停下来. 内心感受到的也不是放松和愉悦, 而只有更深层次的空虚痛苦与厌恶自责. 这些让我们一边上瘾, 又一边厌恶的行为背后, 其实隐藏着的是一种<span class="emp-stye red">心理痛苦.</span> 也就是说, 当一个人内心出现一些负面的情绪和感受, 比如孤独, 压力, 焦虑, 沮丧, 无聊, 抑郁等等, 就会试图通过一些能够在短时间内刺激多巴胺释放的行为, 来覆盖或者排遣掉这些情绪. 当一个人频繁出现负面情绪, 人性趋利避害的本能就会对这些行为产生依赖, 从而变为一个成瘾行为<ul><li>经常感到烦躁焦虑的人, 就容易对吸烟上瘾</li><li>经常感到孤独无聊的人, 就容易对社交平台上瘾</li><li>经常感到压力抑郁的人, 就容易到暴饮暴食上瘾</li></ul></li><li>然而这些行为本身只能暂时缓解负面情绪, 当行为停止, 快乐也会随之消失, 负面感受会再次席卷而来, 甚至变本加厉, 我们又不得不依赖更多的成瘾行为来防御, 从而进入无限的恶性循环. 所以成瘾行为真正的可怕之处, 也是对我们伤害最大的, 并不是这些行为本身带来的后果, 而是我们<spam class="emp-style red">内心反复经受负面情绪与自我厌恶的双重折磨.</span> 这些行为本身沦为一种近乎失控的<strong>精神自毁</strong>. </li><li>对于自己的成瘾行为, 我们真正要解决的问题, 不是如何戒掉和克制行为本身, 而是<span class="emp-style">学会给自己的内心止痛.</span> 否则, 就算靠意志力戒掉表面的成瘾行为, 只要负面情绪的根源没有排除, 或者内心的真实需求没有得到满足, 就一定会再次出现新的成瘾行为. 所以, <span class="emp-stye">当下一次自己再出现上瘾冲动时, 或是上瘾行为无法停下来时, 先闭上眼睛, 深呼吸三次, 然后反问自己:</span> <span class="emp-style yellow">如果现在停下来不去做这件事, 那又会怎么样吗?</span> 这一步是先给自己冲动的欲望一个减速带, 然后启动理性来解决真正的问题. 当渴望得到克制和平息之后, 然后去感受自己此刻真实的情绪和内在渴望. 再接着问自己, <span class="emp-style">为什么此刻我如此渴望多巴胺.</span> 这一步, 是寻找问题的根源, <strong>看到自己真正的情绪问题和内在需求.</strong> 只有直面症结所在, 才能对症下药<ul><li>如果上瘾行为是因为负面情绪, 可以选择更加积极的方式来替代成瘾行为. 可以根据自己的情况, 去<strong>建立一个属于自己的情绪缓冲带</strong>. 面对负面情绪, 正确的做法不是克制压制, 更不是用快感覆盖, 而是彻底地忽略, 让自己的注意力从负面情绪上转移. 一旦你不再主动关注和感受负面情绪, 它们就会像海浪一样逐渐退潮. 所以, 建立能给自己带来正面感受的爱好特别重要. 就算不喜欢运动健身, 也可以选择出门逛街, 打扫房间或者是撸撸宠物一类的事情. 总之, 让自己不再囿于负面情绪本身. 众多爱好: 走到户外, 尽可能接触大自然, 公园散步, 骑骑车, 吹吹风. 尽量离开容易导致自己出现成瘾行为的环境, 去没有天花板的地方找到治愈自己的力量</li><li>如果上瘾行为是因为空虚无聊, 只是想找一些事情来填补时间黑洞, 可以<strong>选择一些能够带来自我成长, 积极影响, 或者更加健康的休息方式.</strong> 取关社交平台上所有刺激多巴胺的碎片化内容, 只关注能够提升认知, 拓展视野的优质信息源以及能让自己感受到平静和愉悦的旅行类, 生活类内容. 让刷手机这件事能够给自己带来正面的影响, 而非无意义的浪费. 可以把睡前刷手机的行为换成睡前看几页书, 因为阅读能够让人拥有获得感和成就感, 比盲目刷手机更能补偿自己白天没有得到满足的情绪</li><li>如果上瘾行为的背后是因为自己需要被看见, 被理解, 被支持, 那就去<strong>找到一段能让自己感到安全和舒服的人际关系, 找一个信任并喜欢的人,</strong> 让对方陪伴你, 聊聊天, 吃吃饭. 高质量的人际关系同样能够让我们得到滋养, 人与人之间的情感流动, 爱与关心, 能够极大地填补我们内心孤独和无助, 让我们感觉到被稳稳地接住, 不再因为<em>精神空寂而自我下坠.</em>*</li></ul></li><li>总之, 无论是通过更加积极健康的爱好, 还是更加有益身心的消遣, 亦或是更加温情脉脉的人际关系, 都能帮助我们走出一边强迫上瘾, 一边自我厌恶的恶性循环. 戒除成瘾行为, 不需要整日清醒克制. 我们需要做的首先是<span class="emp-style">爱自己, 去清楚地看见自己的痛苦和创伤, 勇敢地去面对自己的情绪和需求, 然后帮它们找到更好的安放之处, 让内心止痛.</span></li><li>如果上面的内容都无法摆脱痛苦, 克制上瘾, 那么就请记住一句话: <span class="emp-style yellow">面对生活, 重要的不是治愈, 而是带着遗憾活下去, 并且勇敢地跟痛苦相处.</span></li></ul><h1 id="摆脱自卑拧巴感-尽快消除贫穷感"><a href="#摆脱自卑拧巴感-尽快消除贫穷感" class="headerlink" title="摆脱自卑拧巴感: 尽快消除贫穷感"></a>摆脱自卑拧巴感: 尽快消除贫穷感</h1><ul><li>所谓贫穷感, 一方面是指物质方面的匮乏感, 多花一点钱就会负罪内疚. 对于自己想拥有的东西和想做到的事情, 第一反应就是我不够有钱, 所以不可能得到, 也不可能做到. 另一方面是指<strong>精神上的不配得感</strong>, 认为自己很无能, 不值得, 从而自我设限. 遇到任何机会时, 首先想到的就是不确定性, 不可能性, 进而轻易放弃, 不敢主动争取. 这种物质和精神上的双重贫穷感, 会<span class="emp-style red">极大增强我们对于风险和困难的恐惧意识, 进而极大削弱个人的思考能力和行动能力, 失毁一个人解决问题的能力. </span></li><li>内心存在贫穷感的人, 通常会有三种典型自我设限的心智模式: <strong>没有希望, 无能为力, 没有价值.</strong>     - 没有希望: 认为自己无论怎么努力, 目标都不可能实现, 一旦遭受了一些挫折, 人就会立刻陷入习得性无助的颓丧状态. 凡事总会暗示自己: 我就是做不好, 我命中注定就是这么倒霉<ul><li><strong>无能为力</strong>: 虽然认为目标有可能实现, 但不相信自己有能力得到想要的结果. 抱持这种信念的人, 会自发地给自己设置门槛. 因为自己不够专业, 就放弃理想; 因为自己不够漂亮, 就放弃爱情; 因为自己不够有钱, 就不去做自己想做的事情. 这种无能为力背后的潜台词是, 别人有可能实现这个目标, 但是我不行, 我不够好, 我没有能力, 没有资源去达成目标</li><li><span class="emp-style red">没有价值</span>: 虽然相信目标有可能实现, 甚至相信自己有能力实现, 但却会认为自己不配得到它, 这种心智模式会导致自我认同感很低, 喜欢把自己的缺点无限放大. 明明自己有能力, 却不敢去尝试新事物, 不愿主动争取机会, 也不去拼尽全力追求最好的结果. 这种低价值感传达的信息是, 我什么都不是, 我这个有太多问题, <strong>我不配获得幸福的生活和美好的事物</strong></li></ul></li><li>没有希望, 无能为力, 没有价值这些限制性心智模式, 会在我们的内心架起一堵高墙, 让我们无意识地给自己的人生强加许多枷锁, 让人举步维艰, 画地为牢. 所以要想消除内心的贫穷感, 摆脱限制性信念, 就一定要去<strong>客观地认识自己, 了解自己, 你必须看见一个真实的自己, 认清自己的能力边界, 发掘自己的核心优势, 认可自己的过往经验, 从而找回自我高价值感.</strong></li><li>一个消除自我限制性思维, 最直接最高效的方法: <span class="emp-style yellow">转变自己的语言模式, 从此刻开始, 停止使用一切负面词汇.</span> 当你下次再说出诸如 “我不行”, “我没办法”, “我做不到” 的时候, 你必须有意识地去删除这些限制你思考的负面词语, 然后用正面词语代替. 比如,<ul><li>把 “我没钱”, 变成 “我需要想办法增加收入”</li><li>把 “我社恐”, 变成 “我可以去学习一些处理人际关系的技巧和交流沟通的方法”</li><li>把 “我做不到”, 变成 “我需要去了解更多关于实现这件事的信息, 并且提升完成这件事的对应能力”</li></ul></li><li>当你替换掉负面的限制性词汇, 原本死气沉沉的思维就会开始转动起来. 一旦思维开始流动, 一切就会充满可能性. 只有当你解除了头脑中的限制性信念, 消除了内心中的贫穷感, 你才能拥有让改变发生的力量. <span class="emp-style">如果你想做成一件事, 或成为什么人, 你必须要有非常强大的配得感</span>, 必须是自己一定可以拿下的, 必须是自己一定可以实现的. 相信非我莫属, 相信舍我其谁</li><li>请签下一份<span class="emp-style yellow">人生誓言:</span> <span class="emp-style">无论身处贫寒还是富贵, 健康或是疾病, 抑或其他任何境遇, 我都将永远坚定地站在自己这边, 认可自己, 爱护自己, 尊重自己, 全然接纳自己, 对自己保持永恒的忠诚与坚定, 直至生命的最后一刻</span> ← <strong>我愿意</strong></li></ul><h1 id="熬过任何至暗时刻-定力强者胜"><a href="#熬过任何至暗时刻-定力强者胜" class="headerlink" title="熬过任何至暗时刻: 定力强者胜"></a>熬过任何至暗时刻: 定力强者胜</h1><ul><li>生活的困顿源于对当下处境的陌生和对于未来的恐惧, 而希望来自对自我的理解, 以及对于未来的定力. <span class="emp-style">定力就是无论在何种境况下, 都不丧失对于未来的希望, 都不停止当下的行动.</span> 所谓希望, 不是空想, 不是奢望, 而是一个有意义且有清晰实现路径的目标, 可以拆解为一系列有策略的具体行动, 是能够在日复一日的行动中取得微小进展的事业, 是一个美好而具体的愿景</li><li>自我精神的牢笼是生活中最大的监狱, 命运会将我们关进生活的监狱, 我们像一头受了槌的牛, 问题叠着问题的日子变成了一个缓慢受槌的过程. 一旦磨灭了希望, 停止了抗争, 否定了可塑性, 放弃了寻找出路, 就是画地为牢, 给自己带上了镣铐, 精神中的高墙平地而起, 自己给自己判了终身监禁</li><li>无论身处何种逆境, 只要你清楚地知道你自己是谁, 你不再给自我设限, 你的精神疆域就会变得无限辽阔, 从此希望会让你坚持到底, 定力能带你逃出生天</li><li>表面上的至暗时刻, 其实也是自我最好的扎根期, 保持希望, 保持定力, 学会耐心等待, 等待时机到来, 等待形势变化. 在等待的日子里, 最重要的准备就是: <span class="emp-style yellow">夯实自己的底层基石.</span> 即便我们对于当下的处境有一万个抱怨的理由, 但只要我们能够安心于增加自我的内在价值, 不要过度在意外在世界的波动, 我们就拥有定力, 从而就拥有改变的能力和希望, 好好学习, 认真生活, 积极行动, 不断生成, 持续锻炼自己的身体, 心灵和头脑, 找到一个件能够帮自己积蓄力量的事情, 去花时间偷偷地挖那条越狱的通道, 直到它最终通往你向往的生活</li><li><strong>大劫大难之后, 人该失去锐气, 不该失去热度, 你镇定了但仍在燃烧, 你平稳了却更加浩荡</strong></li></ul><h1 id="解决情绪内耗-我永远有解决问题的能力"><a href="#解决情绪内耗-我永远有解决问题的能力" class="headerlink" title="解决情绪内耗: 我永远有解决问题的能力"></a>解决情绪内耗: 我永远有解决问题的能力</h1><ul><li><p>情绪稳定不是说像机器人一样没有任何情绪, 也不是凡事置身事外, 漠不关心. 情绪稳定的本质是具备快速分析和调整情绪的能力, 不会让任何情绪干扰到自己的行动甚至伤害到自己. 即能够快速跳过与情绪的对抗与纠缠, 直接进入分析问题与解决问题的状态. 跨越情绪的速度越快, 情绪就越稳定, 内核也就越强大</p></li><li><p>关于情绪稳定, 首先要意识到情绪没有好坏之分, 任何情绪都只是一个信号灯, 试图提醒我们自己正在经历什么以及需要面对什么</p></li><li><p>当感受到那些会影响自己状态, 妨碍自己做事, 自己不想要长时间维持的情绪时, 你需要<span class="emp-style">建立一个高维视角, 抽离情绪本身, 进入一个上帝视角, 反问自己: </span></p><ul><li>我为什么会产生这种情绪? </li><li>我的动机是什么? 我想通过这种情绪得到什么? </li><li>有没有更好的方式来获得?</li></ul></li><li><p>即处理任何情绪问题的方法可分三步, 自觉, 理解, 转换</p><ul><li><strong>自觉:</strong> 无论在当前 (下意识) 产生了怎样的情绪反应, 都要先迅速觉察到自己的情绪状态, 然后判断自己当前是什么情绪, 比如感到生气, 委屈, 失望, 伤心. 当能够清楚地看到自己的情绪, 理性的出现已经可以消解一大半情绪的痛苦了</li><li><strong>理解:</strong> 问一下自己我为什么会有这种情绪 (感到失望, 伤心)? 慢慢理解自己情绪背后的动机, 可能会发现<span class="emp-style yellow">自己的情绪跟动机之间往往都不存在必然的逻辑关系,</span> 开始能够从难受的情绪中解脱出来</li><li><strong>转化:</strong> 明确了自己情绪背后的动机, 发现当下的情绪可能都是没有用的, 寻找更好的方法</li></ul></li><li><p>通过建立高维视角, 分三步处理情绪问题, 就拥有了看见, 分析, 并且管理自己情绪的能力. 习惯这种思维方式, 就能做到真正的情绪稳定了. 否则, 情绪就像大脑随机打开的盲盒, 无法驾驭自己的情绪感受, 只能任由自己被情绪操控, 陷入内耗的痛苦. 所以, 解决情绪内耗, 不是和情绪本身对抗, 而是要<span class="emp-style yellow">刻意练习自己认知情绪和拆解情绪的能力</span></p></li><li><p>在还没有熟练掌握建立高维视角的思维习惯之前, 可以通过<span class="emp-style">手写情绪日记</span>的方式帮助自己梳理思路, 看见动机, 化解情绪, 按照自觉, 理解, 转换三个步骤, 去一个字一个字写下自己对于情绪的觉察. 只要愿意开始动笔, 那些在心中剪不断理还乱的思绪和情绪, 都会在写字的过程中越来越清晰和明确, 因为书写本身就具备强大的理性力量, 有助于我们<span class="emp-style red">直视自己的欲望, 恐惧与贪婪, 看清自己的软弱, 无能和嫉妒,</span> 从而逐渐<span class="emp-style">学会勇敢, 克制以及耐心, 会彻底与自己和他人和解, 包容世间一切, 任万事自然流动</span></p></li></ul><h1 id="顶级自律-平静如水的野心"><a href="#顶级自律-平静如水的野心" class="headerlink" title="顶级自律: 平静如水的野心"></a>顶级自律: 平静如水的野心</h1><p><a href="https://www.bilibili.com/video/BV1kcSZYwE8Q?spm_id_from=333.788.videopod.sections&vd_source=23460d5cc9c78243da443476ec5bde1c">当前进度</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Life" scheme="https://zonglin-tian.github.io/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>Word 与排版</title>
    <link href="https://zonglin-tian.github.io/2025/03/03/Word-%E4%B8%8E%E6%8E%92%E7%89%88/"/>
    <id>https://zonglin-tian.github.io/2025/03/03/Word-%E4%B8%8E%E6%8E%92%E7%89%88/</id>
    <published>2025-03-03T05:51:41.000Z</published>
    <updated>2025-08-11T03:09:47.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Word-使用技巧"><a href="#Word-使用技巧" class="headerlink" title="Word 使用技巧"></a>Word 使用技巧</h1><h2 id="文字编辑"><a href="#文字编辑" class="headerlink" title="文字编辑"></a>文字编辑</h2><ul><li>文本大小写转换:<ul><li>快捷键: <code>Shift + F3</code> 来回切换 (全部大写, 全部小写, 首字母大写)</li><li>菜单项: <code>开始</code> 选项卡 → <code>字体</code> 分组 → <code>更改大小写</code> 按钮</li></ul></li></ul><h2 id="参考文献排版"><a href="#参考文献排版" class="headerlink" title="参考文献排版"></a>参考文献排版</h2><h3 id="多个交叉引用"><a href="#多个交叉引用" class="headerlink" title="多个交叉引用"></a>多个交叉引用</h3><ol><li>多篇不连续引用, 如 [1, 3, 5]: 先进行对应文献编号的交叉引用 → 在引用处选中编号, 右键 → 选择 <code>切换域代码</code> → 将 [1] 变为 <code>&#123;... \r \h \#&quot;[0&quot;&#125;</code>, [3] 变为 <code>&#123;... \r \h \#&quot;0&quot;&#125;</code>, 将 [5] 变为 <code>&#123;... \r \h \#&quot;0]&quot;&#125;</code>, 中间再添加逗号分隔即可 → 更新域</li></ol><ul><li><code>\#&quot;[0&quot;</code>: 表示保留左中括号</li><li><code>\#&quot;0&quot;</code>: 表示不要中括号</li><li><code>\#&quot;0]&quot;</code>: 表示保留右中括号</li></ul><ol start="2"><li>多篇连续引用, 如 [1-5]: 只进行第一篇和最后一篇文献编号的引用 → 对于第一个编号保留左中括号, 对于第二个编号保留右中括号 → 更新域</li><li>两个连续引用间使用<strong>逗号+空格</strong>分隔, 如 <code>[1, 2]</code>, 三个及以上的连续引用之间用短横线连接, 如 <code>[1-5]</code></li><li><code>F9</code>: 更新所有域代码 (先 <code>Ctrl + A</code> 选中内容)</li></ol><h2 id="查找与替换使用正则表达式"><a href="#查找与替换使用正则表达式" class="headerlink" title="查找与替换使用正则表达式"></a>查找与替换使用正则表达式</h2><p>开启<code>使用通配符</code>模式</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li>任意数字: <code>[0-9]</code></li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li>换行符: <code>\p</code></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>表达式查找: <code>()</code></li><li>占位: <code>\数字</code></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/142237132">嘟嘟. Word多参考文献连续交叉引用. 知乎</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/399183452">CSer. word和正则表达式. 知乎</a></p><h1 id="Mathtype-公式录入"><a href="#Mathtype-公式录入" class="headerlink" title="Mathtype 公式录入"></a>Mathtype 公式录入</h1><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li>显示空格或者制表符: 菜单栏[视图] → 全部显示[选中]</li></ul><h2 id="空格与对齐"><a href="#空格与对齐" class="headerlink" title="空格与对齐"></a>空格与对齐</h2><ul><li>空格: 0, 1, 2, 3, 4 宽度种空格, 对应快捷键为 <code>Ctrl + K</code> + <code>空格宽度</code></li><li>快速插入 0&#x2F;1 宽度空格: <code>Shift + Space</code>&#x2F;<code>Ctrl + Alt + Space</code></li><li>文本空格: 将模式切换成文本, 然后 <code>Space</code> 键即为普通意义的空格</li><li>制表符对齐: 如果未在标尺上点击位置, 按下 <code>Ctrl + Tab</code> 自动对齐到<strong>整数</strong>刻度位置</li><li>对齐符号: 在想对齐位置处按下 <code>Ctrl + ;</code> (或者通过菜单栏插入), 可实现多行公式在等号处对齐等效果; 对于没有插入对齐符号的行, 默认在公式<strong>最前端</strong>对齐</li></ul><p align="center"><img src="/img/posts/Word-与排版/space_align.png" style="height:250px" alt="空格示意图与插入菜单"/></p><h2 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/zch19960629/article/details/88430098">Christopher Cheung. MathType中输入空格的方法. CSDN</a></p><h1 id="域代码"><a href="#域代码" class="headerlink" title="域代码"></a>域代码</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>插入域符号: <code>Ctrl + F9</code> or [菜单]插入 → [文本]文档部件 → 域</li><li>更新域: <code>F9</code> (需要先选中内容)</li><li>显示&#x2F;隐藏域代码: <code>Shift + F9</code> (需要先选中内容或将光标放在内容之前[单个]), <code>Alt + F9</code> (显示所有域代码)</li></ul><h2 id="常用域代码"><a href="#常用域代码" class="headerlink" title="常用域代码"></a>常用域代码</h2><ul><li>编号项 (生成整数序列): <code>SEQ Equation</code> (Equation 是序列名)</li></ul><h1 id="自带公式编辑器使用技巧"><a href="#自带公式编辑器使用技巧" class="headerlink" title="自带公式编辑器使用技巧"></a>自带公式编辑器使用技巧</h1><h2 id="基本输入"><a href="#基本输入" class="headerlink" title="基本输入"></a>基本输入</h2><ul><li>输入方式可选择 LaTeX, 然后转制成公式 (专业)</li><li>公式后紧根空格可触发公式自动转换</li><li><code>()</code> 可用于界定结构子内容边界</li><li>选中内容, 点击<code>文本</code>可设置特殊字体格式</li></ul><h2 id="插入编号的公式"><a href="#插入编号的公式" class="headerlink" title="插入编号的公式"></a>插入编号的公式</h2><ul><li>✅ 自动转换: <code>Contents#()Enter</code> (不支持字体更改)</li><li>创建<code>公式</code>样式, 设定居中对齐与右对齐制表位</li><li>动态编号<ul><li>✅ 插入域代码 (<code>Ctrl + F9</code>) → <code>&#123; SEQ Equation \* MERGEFORMAT &#125;</code> </li><li>插入题注 + <strong>样式分隔符[同一段落实现不同样式]</strong> (<code>Ctrl + Alt + Enter</code>)</li></ul></li></ul><h2 id="公式编号交叉引用"><a href="#公式编号交叉引用" class="headerlink" title="公式编号交叉引用"></a>公式编号交叉引用</h2><ul><li>✅ 域代码编号: 选中编号建立书签 → 交叉引用对应的书签 (相当于 LaTeX 公式中的 <code>label</code>)</li><li>题注方式编号: 交叉引用对应的题注</li></ul><h2 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h2><p>[1] <a href="http://www.hanlindong.com/2021/word-equation/">董翰林. Word 公式编辑器的优雅使用方法</a></p><h1 id="插入-Unicode-编码字符"><a href="#插入-Unicode-编码字符" class="headerlink" title="插入 Unicode 编码字符"></a>插入 Unicode 编码字符</h1><ul><li>Unicode: 全球统一的字符编码标准, 为每个符号分配唯一的十六进制编号 (至多 4 位)</li><li><strong>输入 Unicode 编码之后, 按 <code>Alt + X</code> 直接转换为相应字符</strong> </li><li><strong>在特殊字符之后, 按 <code>Alt + X</code> 可得到相应的 Unicode 编码</strong></li><li><a href="https://symbl.cc/">Unicode 字符编码查询</a></li></ul><h2 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h2><ul><li>带圈数字: ①-⑩ → 2460-2469</li></ul><h2 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h2><ul><li>偏导数: ∂ → 2202</li></ul>]]></content>
    
    
    <summary type="html">Word 常用排版技巧</summary>
    
    
    
    <category term="Software" scheme="https://zonglin-tian.github.io/categories/Software/"/>
    
    
    <category term="Typesetting" scheme="https://zonglin-tian.github.io/tags/Typesetting/"/>
    
  </entry>
  
  <entry>
    <title>专业单词与术语</title>
    <link href="https://zonglin-tian.github.io/2025/02/20/%E4%B8%93%E4%B8%9A%E5%8D%95%E8%AF%8D%E4%B8%8E%E6%9C%AF%E8%AF%AD/"/>
    <id>https://zonglin-tian.github.io/2025/02/20/%E4%B8%93%E4%B8%9A%E5%8D%95%E8%AF%8D%E4%B8%8E%E6%9C%AF%E8%AF%AD/</id>
    <published>2025-02-20T14:09:55.000Z</published>
    <updated>2025-02-20T14:21:00.517Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h1><h1 id="英文单词"><a href="#英文单词" class="headerlink" title="英文单词"></a>英文单词</h1><ul><li>steer: v. 驾驶; 操纵; <strong>控制; 引导</strong>; 行驶; 掌控方向盘</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Research" scheme="https://zonglin-tian.github.io/categories/Research/"/>
    
    
  </entry>
  
  <entry>
    <title>Git-GitBash-GitHub</title>
    <link href="https://zonglin-tian.github.io/2025/02/13/Git-GitBash-GitHub/"/>
    <id>https://zonglin-tian.github.io/2025/02/13/Git-GitBash-GitHub/</id>
    <published>2025-02-13T14:03:58.000Z</published>
    <updated>2025-02-13T14:25:21.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>查看配置: <code>git config --list</code></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li>clone 特定版本的仓库: <code>git clone --branch &lt;version&gt; repository_url</code></li><li>代理管理<ul><li>设置: <code>git config --global http.proxy 127.0.0.1:12345</code></li><li>取消: <code>git config –-global –unset http.proxy</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Git Git Bash GitHub 操作</summary>
    
    
    
    <category term="Software" scheme="https://zonglin-tian.github.io/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows Terminal</title>
    <link href="https://zonglin-tian.github.io/2025/01/07/Windows-Terminal/"/>
    <id>https://zonglin-tian.github.io/2025/01/07/Windows-Terminal/</id>
    <published>2025-01-07T00:48:18.000Z</published>
    <updated>2025-04-22T08:43:04.706Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="以应用为导向"><a href="#以应用为导向" class="headerlink" title="以应用为导向"></a>以应用为导向</h1><ul><li><p>查看命令的帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">help cmd<br></code></pre></td></tr></table></figure></li><li><p>查看别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">CMD</span><br>doskey /macros<br><span class="hljs-meta prompt_"># </span><span class="language-bash">PowerShell</span><br>Get-Alias<br></code></pre></td></tr></table></figure></li><li><p>查看系统环境变量</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">CMD</span><br>set  # 显示所有环境变量<br>echo %var_name%  # 显示某个环境变量的值<br>set var_name=value  # 查置环境变量的值<br><span class="hljs-meta prompt_"># </span><span class="language-bash">PowerShell</span><br>Get-ChildItem/dir ENV:  # 显示所有环境变量<br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">env</span>:var_name  <span class="hljs-comment"># 显示某个环境变量的值</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">env</span>:Path -<span class="hljs-built_in">split</span> <span class="hljs-string">&#x27;:&#x27;</span>  <span class="hljs-comment"># 分行查看环境变量 Path 的值</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-built_in">env</span>:Path -<span class="hljs-built_in">split</span> <span class="hljs-string">&#x27;:&#x27;</span> | sls Python  <span class="hljs-comment"># 查找 Path 中包含 &#x27;Python&#x27; 的路径</span></span><br></code></pre></td></tr></table></figure><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><ul><li>将命令输出到粘贴板: <code>cmd | clip</code></li></ul><h1 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h1><ul><li>配置文件位置: <code>echo $PROFILE</code></li><li>修改配置文件: <code>vim $PROFILE</code></li><li><strong>配置文件立即生效: <code>. $PROFILE</code></strong></li></ul><h1 id="ps1"><a href="#ps1" class="headerlink" title=".ps1"></a><code>.ps1</code></h1><p>- </p>]]></content>
    
    
    <summary type="html">Windows CMD (.bat) 与 PowerShell (.ps1) 操作</summary>
    
    
    
    <category term="Windows" scheme="https://zonglin-tian.github.io/categories/Windows/"/>
    
    
    <category term="Writing..." scheme="https://zonglin-tian.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>Shell 脚本</title>
    <link href="https://zonglin-tian.github.io/2024/12/04/Shell-%E8%84%9A%E6%9C%AC/"/>
    <id>https://zonglin-tian.github.io/2024/12/04/Shell-%E8%84%9A%E6%9C%AC/</id>
    <published>2024-12-04T01:57:31.000Z</published>
    <updated>2025-05-19T01:42:16.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h1><ul><li>空格: 赋值语句 <code>=</code> 两边不能有空格, 测试语句 <code>[]</code>内必须有空格分隔</li><li>引号<ul><li><p>变量, 命令替换, 含空格&#x2F;特殊字符的字符串 (文件名) 必须加引号</p><ul><li>默认用双引号 <code>&quot;&quot;</code> (防止空格&#x2F;特殊字符问题): 变量扩展, 支持转义字符</li><li>不需要变量扩展时单引号 <code>&#39;</code> (正则表达式): <strong>静态字符</strong>, 完全原样输出</li></ul></li><li><p><code>test</code> 或 <code>[]</code> 条件判断中变量比较必须加引号</p></li></ul></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>变量引用: <code>value=&quot;$Var_name&quot;</code></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/452686607">Soler索莱尔HO. 一文掌握shell脚本的基本语法. 知乎</a><br>[2] <a href="https://blog.csdn.net/u012294618/article/details/78427864">Pikachu5808. 释伴：Linux 上的 Shebang 符号(#!). CSDN</a></p>]]></content>
    
    
    <summary type="html">Shell 脚本语法</summary>
    
    
    
    <category term="Coding" scheme="https://zonglin-tian.github.io/categories/Coding/"/>
    
    <category term="Ubuntu" scheme="https://zonglin-tian.github.io/categories/Ubuntu/"/>
    
    
    <category term="Writing..." scheme="https://zonglin-tian.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>Hello Docker</title>
    <link href="https://zonglin-tian.github.io/2024/11/28/Hello-Docker/"/>
    <id>https://zonglin-tian.github.io/2024/11/28/Hello-Docker/</id>
    <published>2024-11-28T02:39:11.000Z</published>
    <updated>2024-11-28T03:25:58.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="最常用命令"><a href="#最常用命令" class="headerlink" title="最常用命令"></a>最常用命令</h1><ul><li>列出已有镜像: <code>docker image ls</code></li><li>镜像打包: <code>docker save -o file_name.tar &quot;img_name:img_tag&quot;</code></li><li>根据镜像创建实例:  <code>docker run -it --gpus all --name instance_name img_name:img_tag /bin/bash</code></li><li>根据 Dockerfile 创建镜像: <code>docker build -t img_name:img_tag</code></li><li>列出正在运行的实例: <code>docker ps</code></li></ul><h1 id="Dockerfile-语句"><a href="#Dockerfile-语句" class="headerlink" title="Dockerfile 语句"></a>Dockerfile 语句</h1><ul><li>FROM: 基础镜像名与标签</li><li>ENV: 设置环境变量</li><li>ARG: 创建镜像时的参数</li><li>WORKDIR: 设置镜像当前目录</li><li>COPY: 从本地复制内容到镜像</li></ul>]]></content>
    
    
    <summary type="html">Docker 常用命令</summary>
    
    
    
    <category term="Software" scheme="https://zonglin-tian.github.io/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>终端 Python: IPython</title>
    <link href="https://zonglin-tian.github.io/2024/10/25/Terminal-Python-IPython/"/>
    <id>https://zonglin-tian.github.io/2024/10/25/Terminal-Python-IPython/</id>
    <published>2024-10-25T02:39:33.000Z</published>
    <updated>2024-12-31T07:39:21.466Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>IPython 提供了一个丰富的工具包, 可以最大限度以交互方式使用 Python, 主要由两部分组成:</p><ul><li>交互式 Python shell</li><li>一个 Jupyter 内核</li></ul><h1 id="历史输入与输出"><a href="#历史输入与输出" class="headerlink" title="历史输入与输出"></a>历史输入与输出</h1><ul><li>hist: 查看历史输入, <code>-n</code> 则额外显示输入序号</li><li>_: 查看最近的一个<em>输出</em>结果</li><li>_n: 查看指定序号 n 的输出结果</li><li>_i: 查看最近的一个输入</li><li>_iN: 查看指定序号的输入</li></ul><h1 id="内省-内视功能"><a href="#内省-内视功能" class="headerlink" title="内省 (内视功能)"></a>内省 (内视功能)</h1><ul><li>object? 或者 ?object: 显示对象的一些通用信息</li><li>object?? 或者 ??object: 显示对象详细信息, 对于类或者函数, 将会显示源码</li><li>numpy.*load*?: 显示所有包含 load 的 numpy 函数</li><li>numpy.*sort?: 显示所有以 sort 结尾的 numpy 函数</li></ul><h1 id="魔术命令"><a href="#魔术命令" class="headerlink" title="魔术命令"></a>魔术命令</h1><p>Magic command 是常规 Python 代码的增强版, 通常由 <code>IPython</code> 的内核提供, 以 <code>%</code> 字符为前缀, 一共有两种魔术命令: </p><ul><li>% 前缀: 命令在一行代码上运行</li><li>%% 前缀: 命令在整个单元格上运行</li></ul><p><strong>默认情况下, 魔术命令总是以 % 分号开头, 但这不是必须的, 也可以直接使用不带 % 的魔术命令, 这称之为 <code>自动魔术命令 (automagic)</code></strong>. 当使用自动魔术命令时, 不能出现和魔术命令同名的变量, 否则显示的是变量. <strong>可以使用 <code>%automagic</code> 来切换是否开启自动魔术命令</strong></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>quickref: 显示 ipython 的快速参考</li><li><strong>lsmagic: 列出所有魔术命令</strong></li><li><strong>mc? 或者 ?mc: 显示魔术命令的帮助信息</strong></li><li>magic: 列出所有魔术命令的详细信息</li><li><strong>run file.py: 运行脚本</strong></li><li><strong>pycat file.py: 显示脚本内容</strong></li><li>writefile file.py: 将内容写入脚本 (-a 表示追加)</li><li>paste: 运行粘贴板上的代码</li><li><strong>查看变量</strong><ul><li>who: 依次显示所有变量的名称</li><li>whols: 以列表的形式显示所有变量的名称</li><li>whos: 显示所有变量的详细信息</li></ul></li><li><strong>变量删除</strong><ul><li>xdel var_name 或者 del var_name: 删除变量 var_name</li><li>resest: 删除交互命名空间中所有变量</li></ul></li><li><strong>调试</strong><ul><li>debug: 运行代码出现问题后, 使用此命令将回溯到代码异常处, 并进入调试模式</li><li>pdb: 运行代码出现问题时, 将自动进入调试模式</li></ul></li></ul><h1 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h1><p>以 <code>!</code> 开头的命令可直接在 Python 环境中执行操作系统中 shell 命令</p><ul><li>!cmd: 打开 CMD</li><li>!pwd: 当前目录</li><li>!echo $HOME: 查看环境变量 $HOME</li><li>!python train.py: 运行 python 程序</li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li>向前查找以当前输入的文本开头的历史命令: <code>Ctrl + P</code></li><li>向后查找以当前输入的文本开头的历史命令: <code>Ctrl + N</code></li><li>从剪贴板粘贴文本: <code>Ctrl + Shift + V</code></li><li>将光标移至行首: <code>Ctrl + A</code></li><li>将光标移至行尾: <code>Ctrl + E</code></li><li>删除从光标开始至行尾的文本: <code>Ctrl + K</code></li><li>删除光标以前的所有文本: <code>Ctrl + U</code></li><li>清屏: <code>Ctrl + L</code></li><li>移动一个字符: <code>Ctrl + B/F</code></li></ul><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><h2 id="给系统-shell-命令定义一个别名作为魔术命令"><a href="#给系统-shell-命令定义一个别名作为魔术命令" class="headerlink" title="给系统 shell 命令定义一个别名作为魔术命令"></a>给系统 shell 命令定义一个别名作为魔术命令</h2><h2 id="给文件目录定义一个书签-快速访问"><a href="#给文件目录定义一个书签-快速访问" class="headerlink" title="给文件目录定义一个书签, 快速访问"></a>给文件目录定义一个书签, 快速访问</h2><h2 id="以-Vim-模式输入命令"><a href="#以-Vim-模式输入命令" class="headerlink" title="以 Vim 模式输入命令"></a>以 Vim 模式输入命令</h2><ul><li>临时配置: 在 IPython 内输入: <code>%config TerminalInteractiveShell.editing_mode = &#39;vi&#39;</code></li><li>查询当前输入模式: <code>%config TerminalInteractiveShell.editing_mode</code></li><li>永久配置: 编辑或者创建位于 <code>~/.ipython/profile_default/</code> 目录下的  <code>ipython_config.py</code> 文件, 添加下列行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">c.TerminalInteractiveShell.editing_mode = <span class="hljs-string">&#x27;vi&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://blog.csdn.net/qq_27825451/article/details/84320859?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-84320859-blog-53086766.235%5Ev39%5Epc_relevant_yljh&spm=1001.2101.3001.4242.2&utm_relevant_index=2">LoveMIss-Y. 史上最详细、最完全的ipython使用教程，Python使用者必备！——ipython系列之一. CSDN</a><br>[2] <a href="https://ipython.readthedocs.io/en/stable/">IPython. Document</a><br>[3] <a href="https://marketsplash.com/tutorials/ipython/ipython-vim-mode/#:~:text=Setting%20Up%20IPython%20Vim%20Mode%201%20IPython%20Installation,...%205%20Checking%20Your%20Vim%20Mode%20Status%20">How To Use IPython Vim Mode Effectively</a></p>]]></content>
    
    
    <summary type="html">IPython 终端操作</summary>
    
    
    
    <category term="Coding" scheme="https://zonglin-tian.github.io/categories/Coding/"/>
    
    
    <category term="Python" scheme="https://zonglin-tian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>完美淡然, 缺憾坦然</title>
    <link href="https://zonglin-tian.github.io/mood/%E5%AE%8C%E7%BE%8E%E6%B7%A1%E7%84%B6-%E5%A4%B1%E6%84%8F%E5%9D%A6%E7%84%B6/"/>
    <id>https://zonglin-tian.github.io/mood/%E5%AE%8C%E7%BE%8E%E6%B7%A1%E7%84%B6-%E5%A4%B1%E6%84%8F%E5%9D%A6%E7%84%B6/</id>
    <published>2024-10-16T14:00:00.000Z</published>
    <updated>2025-04-09T05:08:09.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p style="text-align:center;font-weight:bold;font-size:18pt">我今天觉察到自己陷入悲伤</p><h1 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h1><ul><li>含泪经验: 对于长期使用的东西 (比如电车, 自行车), 尽可能在周边实体店买, <strong>售后大于一切</strong></li><li>当很努力地去做一件事后, 完美&#x2F;得之淡然, 缺憾坦然</li></ul><h1 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h1><p>国庆前几天网购了一台可骑行的自行车 (848 元), 骑行了几次, 总感觉有些小问题 (外观属实精美). 其中一个核心的问题是: 用力踩时链条会 “打滑”, 导致踩空, 重心失衡, 比较危险. 我在最开始的时候, 以为这个问题是 “跳链” 或者 “跳档” 所引起的. 店家在线给出一些解决方案, 我实操. 这个过程怎么说好呢, 感觉就像在抛骰子一般, 我一遍遍试, 能不能有效果全靠运气. 昨天晚上, 吃完晚饭我再次尝试店家给出的一个 “简单” 方法, 结果一试试一个晚上, 还没试出个所以然. 今早, 我将自行车骑到附近的两个实体店进行调试. 师傅给出的回答, 让我基本没有再继续调试的念头. <strong>“这个车子好多配件不合格, 修不好.”</strong> 现在想起, 我的车子肯定是存在问题的, 但其实应该没有师傅说的那么夸张 (可能更多的是, 我没在修车师傅那里买车, 他不想花心思给修…). </p><p>联想起博士刚入学的那一年, 我也是在网上买的电瓶车, 后面为了上牌照, 真可谓四处奔波: 大冬天的, 骑着车去离学校 10 公里左右的车管所上牌照. 结果因为一些参数不符合标准, 不能上牌照, 可谓雪上加霜… (不要问我现在的牌照哪里来的, 劳动人民的智慧使然) 尤其是后面了解到, 离学校三公里左右的地方就有卖电车的, 并且包办上牌照, 我现在都想像不了当时有多后悔. 结果, 我还是没记住这个教训, 再次跌倒在同一个地方: 网购自行车. 这样的坑我不想再踩了: <strong>不要轻易在网上购买可能需要长期售后的东西</strong>. </p><p>我觉得我这个人的一个特点是: 当一个事情发生了, 尽管我追悔莫及, 但我还是愿意努力去解决. 买电瓶车不方便上照牌, 我还是愿意大冷天去上牌照. 自行车出问题了, 我还是愿意花时间调试, 甚至到实体店找师傅帮忙. 简单来说, 可能就是能吃苦吧? 但当车管所的相关人员告诉我车辆不规范无法上牌照, 自行车修车师傅说车子参数不对无法修好时, 一股<strong>无力感</strong>袭来. 我是个完美主义, 为了做好一件事, 我愿意投入大量的时间和精力 (相对来说), 但当最后我发现这件事基本超出我的能力范围之外或者不以我的投入而改变时, 确实让我很受挫. 对此, 我希望自己以后仍然能有尽力做好一件事的心态, 但对于结果能有<strong>得之淡然, 缺憾坦然</strong>的心态. 抑或是: 尽人事, 听天命. 人生三件大事: </p><ul><li>求学 (理想的毕业院校与科研成果)</li><li>恋爱&#x2F;结婚 (理想的另一半)</li><li>工作 (理想的职位与薪资)</li></ul><h1 id="觉察"><a href="#觉察" class="headerlink" title="觉察"></a>觉察</h1><p>我今天主要感受到伤心与挫败感, 因为尽管自己很想修好自行车, 而且确实也花了时间精力, 但还是修不好. 再想到是车子质量的问题, 对于自己网购自行车这一行为产生了后悔与自责的情绪. </p><p>小天使: 这个事和你的<strong>人生主线</strong>关系不大, 大不了咱重新在实体店买一辆好了. 要说稍微值得记住的不过是前面的两点经验, 从三个月, 一年后再来看这件事, 没准会有意想不到的收获. 和自己和解, 努力向前走吧, 加油!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Grocery" scheme="https://zonglin-tian.github.io/tags/Grocery/"/>
    
    <category term="Writing..." scheme="https://zonglin-tian.github.io/tags/Writing/"/>
    
  </entry>
  
  <entry>
    <title>心理辅导</title>
    <link href="https://zonglin-tian.github.io/2024/10/14/%E5%BF%83%E7%90%86%E8%BE%85%E5%AF%BC/"/>
    <id>https://zonglin-tian.github.io/2024/10/14/%E5%BF%83%E7%90%86%E8%BE%85%E5%AF%BC/</id>
    <published>2024-10-14T00:36:48.000Z</published>
    <updated>2024-10-19T00:16:58.726Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="拖延应对"><a href="#拖延应对" class="headerlink" title="拖延应对"></a>拖延应对</h1><h2 id="拖延分析"><a href="#拖延分析" class="headerlink" title="拖延分析"></a>拖延分析</h2><ul><li>在什么领域或者情况下拖延 <ul><li>主要集中在科研或者一些自己不擅长的事上</li></ul></li><li>拖延时的情形<ul><li>不知道怎么做, 有较大畏难情绪, 转而去做其它事情, 偏离主线<ul><li>完善博客&#x2F;阅读&#x2F;跑步&#x2F;购物&#x2F;刷短视频&#x2F;看小说 (做相对容易的事)</li></ul></li><li>尽管理智上要求自己紧盯主线, 但投入与产出的不平衡, 使得无法形成良好的正反馈, 行动上仍然迟缓</li></ul></li><li>拖延持续多久了? 给你带来了什么好处?<ul><li>从博士入学到现在</li><li>让我不至于心理崩溃</li></ul></li><li>我的拖延小怪兽: 大眼睛 (当我不看或者面对他时, 会受到惩罚)</li></ul><div style="text-align: center">    <img src="/img/posts/心理辅导/big_eye.jpg" style="zoom:15%"/></div><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><p>当你拖延时, 内心的小怪兽是怎么和你说话的? 些时, 你如何反驳他?</p><ul><li>我内心不够安静, 无法静下心来做事, 等我内心安静下先 (状态未准备好)<ul><li>你为什么内心不够安静?</li><li>拖延或者做什么能让你内心安静下来吗?</li></ul></li><li>还没想好怎么做, 不清楚怎么做 (能力&#x2F;知识未准备好)<ul><li>是一点都不知道怎么做吗? 计划拆解了啊</li></ul></li><li>担心 (害怕) 结果不好, 不想开始<ul><li>一直不开始, 结果会变好吗?</li></ul></li><li>还有时间, 可以再等等<ul><li>真的还有时间吗? 这周的安排挺紧凑的</li></ul></li><li>反正来不及了, 做不好了, 不必要了</li></ul></li><li><p>详细方法</p><ul><li>实在拖延时, 仍尽量做和主线相关的事</li></ul></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>事情的重要性, 难易程度以及我们的兴趣与我们是否拖延有一定相关性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Others" scheme="https://zonglin-tian.github.io/categories/Others/"/>
    
    
    <category term="Grocery" scheme="https://zonglin-tian.github.io/tags/Grocery/"/>
    
  </entry>
  
  <entry>
    <title>CUDA Toolkit of Conda and Local</title>
    <link href="https://zonglin-tian.github.io/2024/10/10/CUDA-Toolkit-of-Conda-and-Local/"/>
    <id>https://zonglin-tian.github.io/2024/10/10/CUDA-Toolkit-of-Conda-and-Local/</id>
    <published>2024-10-10T06:28:47.000Z</published>
    <updated>2025-04-07T02:38:37.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note note-warning">            <p><strong>Warning:</strong><br>本人对这一块的相关概念理解不深, 主要从解决实际问题的角度出发, 慎重参考</p>          </div><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以 ubuntu 服务器为例, 下面三种情况可能涉及到 cuda 版本的问题</p><ol><li><code>nvidia-smi</code>: 显卡驱动</li><li><code>nvcc -V</code>: 从 <a href="https://developer.nvidia.com/cuda-toolkit-archive">NVIDIA CUDA 官网</a>安装的 CUDA Toolkit 的 cuda 驱动</li><li><code>conda install pytorch==2.3.1 torchvision==0.18.1 torchaudio==2.3.1 pytorch-cuda=12.1 -c pytorch -c nvidia</code>: conda 安装 PyTorch 时, 安装的 cuda 驱动</li></ol><p><strong>存在性与版本兼容性:</strong></p><ul><li>1 必须存在, 2 与 3 可同时存在也可只含其一</li><li>1 的版本号必须<strong>不小于</strong> 2 和 3 的版本号</li></ul><h1 id="CUDA-自定义安装"><a href="#CUDA-自定义安装" class="headerlink" title="CUDA 自定义安装"></a>CUDA 自定义安装</h1><ul><li><p>通过 <code>nvidia-smi</code> 查看当前显卡驱动版本 (若没有安装, 可在后续安装 CUDA Toolkit 时选中 <code>Driver</code> 进行安装)</p></li><li><p>到<a href="https://developer.nvidia.com/cuda-toolkit-archive">官网</a>下载对应版本的 CUDA Toolkit (向下兼容). 以 ubuntu 20.04 安装 12.4.0 为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Linux → x86_64 → Ubuntu → 20.04 → runfile (local) → 查看下方的 Installation Instructions</span><br>wget https://developer.download.nvidia.com/compute/cuda/12.4.0/local_installers/cuda_12.4.0_550.54.14_linux.run<br><span class="hljs-comment"># 当想自定义安装位置在个人工作目录下时, 命令可不以 sudo 开头</span><br>sudo sh cuda_12.4.0_550.54.14_linux.run<br></code></pre></td></tr></table></figure></li><li><p><span class="emp-style red">安装关键之处</span></p><ol><li>通常不需勾选安装&#x2F;更新显卡驱动 (若要勾选, 前面的命令应以 <code>sudo</code> 开头)</li><li>对于深度学习, 一般只需勾选第二个 <code>CUDA Toolkit</code>, 后面的不需要  <div style="text-align: center;">  <img src="/img/posts/CUDA-Toolkit-of-Conda-and-Local/cuda_install.png" style="zoom:80%">  </div></li><li><strong>点击 <code>Options</code> → <code>Toolkit Options</code> 可自定义 CUDA 安装位置</strong> (最后的 <code>Library install path</code> 通常不需要管)</li><li>一切定义好之后, 点击 <code>Install</code></li><li>安装完成后会有相关提示, 可复制其中的<strong>路径</strong>, 方便后面定义环境变量</li></ol></li><li><p>定义相关环境变量, 写入 <code>.bashrc</code> 或者 <code>.zshrc</code> 文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 对于自定义 cuda 安装位置, 必不可少</span><br><span class="hljs-comment"># 以 cuda-12.4 为例, 语句中的路径需要替换为前面安装完成时的输出路径</span><br><span class="hljs-built_in">export</span> CUDA_HOME=/usr/local/cuda-12.4/<br><span class="hljs-built_in">export</span> PATH=/usr/local/cuda-12.4/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda-12.4/lib64:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># nvcc 有定义或者路径正确</span><br><span class="hljs-built_in">which</span> nvcc  <span class="hljs-comment"># 输出的前缀应以安装的 cuda 的路径为前缀</span><br>nvcc -V  <span class="hljs-comment"># 输出应为安装的 cuda 版本</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="多版本-CUDA-切换"><a href="#多版本-CUDA-切换" class="headerlink" title="多版本 CUDA 切换"></a>多版本 CUDA 切换</h1><p><strong>确定顺序: <code>CUDA_HOME/CUDA_PATH</code> → <code>which/where nvcc</code> → <code>/usr/local/cuda | C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v*.*</code></strong></p><p>当 2 和 3 同时存在或者第 2 种情况下安装有多个版本的 CUDA Toolkit, 代码运行时, 需要根据实际情况指定默认的 cuda 版本. </p><p><strong>查看当前默认的 cuda:</strong> <code>which nvcc</code> 输出的向上两级目录</p><ul><li>例 1: 假设 2 和 3 同时并存, 默认使用 3 中的 cuda, <em><strong>如何指定 2 中的 cuda 为默认值是个问题?</strong></em><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看 PyTorch 编译时 cuda 的版本</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-comment"># torch.__version__</span><br><span class="hljs-comment"># torch.cuda.is_available()</span><br>torch.version.cuda<br><span class="hljs-comment"># 查看 PyTorch 运行时调用的 cuda 版本</span><br><span class="hljs-keyword">import</span> torch.utils.cpp_extension<br>torch.utils.cpp_extension.CUDA_HOME<br></code></pre></td></tr></table></figure></li><li>例 2: 假设 2 中同时存在多个版本 cuda, 指定特定版本号的 cuda 为默认值 (<em><strong>对基于 Tensorflow 的任务可能较常遇到</strong></em>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 假设安装的 cuda 都在 /usr/local/ 下, 有 cuda-12.1, cuda-12.4</span><br><span class="hljs-comment"># 在 .bashrc 或者 .zshrc 文件中定义或者修改和 cuda 相关的环境变量</span><br><br><span class="hljs-comment"># 定义 CUDA_VERSION 这个变量使得后续更改更优雅</span><br><span class="hljs-comment"># 完全可以不用定义, 之后的更改使用完全显示的路径即可</span><br><span class="hljs-built_in">export</span> CUDA_VERSION=12.4<br><span class="hljs-built_in">export</span> CUDA_HOME=/usr/local/cuda-<span class="hljs-variable">$CUDA_VERSION</span>/<br><span class="hljs-built_in">export</span> PATH=/usr/local/cuda-<span class="hljs-variable">$CUDA_VERSION</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda-<span class="hljs-variable">$CUDA_VERSION</span>/lib64:<span class="hljs-variable">$LD_LIBRARY_PATH</span><br><span class="hljs-comment"># 当只是临时指定, 可直接在终端输入</span><br><span class="hljs-comment"># 保存退出</span><br><span class="hljs-built_in">source</span> .bashrc <span class="hljs-comment"># source .zshrc</span><br><span class="hljs-comment"># 验证是否设置正确</span><br><span class="hljs-built_in">which</span> nvcc  <span class="hljs-comment"># 输出结果应为 /usr/local/cuda-12.4/bin/nvcc</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="cuDNN"><a href="#cuDNN" class="headerlink" title="cuDNN"></a>cuDNN</h1><p>cuDNN 是针对深度神经网络中的基础操作而设计基于 GPU 的加速库, 前面 3 会自动安装相应的 cuDNN, 当只是 2 存在时, 需要额外安装 cuDNN 并对相关文件复制&#x2F;移动</p><div class="note note-warning">            <p><strong>个人理解:</strong></p><ol><li>基于 PyTorch 的深度学习任务, 按照<a href="https://pytorch.org/get-started/previous-versions/">官网</a>提供的命令进行安装即可, <strong>不需要</strong>额外安装 CUDA Toolkit 与 cuDNN</li><li>基于 Tensorflow 的深度学习任务需要根据要安装的 <a href="https://tensorflow.google.cn/install/source#linux"><strong>Tensorflow 版本</strong></a>来安装相应版本的 CUDA Toolki 与 cuDNN, 并通常涉及到<a href="/2024/10/10/CUDA-Toolkit-of-Conda-and-Local/#%E5%A4%9A%E7%89%88%E6%9C%AC-cuda-%E5%88%87%E6%8D%A2"><strong>多版本 CUDA 切换</strong></a></li></ol>          </div><p><span style="font-size:15pt;font-weight:bold;color:red">Steps:</span> </p><ul><li>安装显卡驱动与 CUDA Toolkit (假设都为 12.4)</li><li>到<a href="https://developer.nvidia.com/rdp/cudnn-archive">官网</a>下载对应的 cuDNN 版本 (比如 v8.9.7) → <code>Local Installer for Linux x86_64 (Tar)</code> → 上传到服务器</li><li>解压缩上面的 <code>.tar.xz</code> 文件并复制相关文件到对应的 CUDA 目录下. 以 <code>/usr/local/cuda-12.4/</code> 为例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压缩</span><br>tar -xvf cudnn-linux-x86_64-8.9.7.29_cuda12-archive.tar.xz<br><span class="hljs-built_in">cd</span> cudnn-linux-x86_64-8.9.7.29_cuda12-archive<br><span class="hljs-comment"># 复制文件</span><br>sudo <span class="hljs-built_in">cp</span> include/cudnn*.h /usr/local/cuda-12.4/include<br>sudo <span class="hljs-built_in">cp</span> lib/libcudnn* /usr/local/cuda-12.4/lib64<br><span class="hljs-comment"># 为所有用户添加读权限 (可选, 通常都具有读的权限)</span><br>sudo <span class="hljs-built_in">chmod</span> a+r /usr/local/cuda-12.4/include/cudnn*.h<br>sudo <span class="hljs-built_in">chmod</span> a+r /usr/local/cuda-12.4/lib64/libcudnn*<br><span class="hljs-comment"># 查看 cuDNN 信息</span><br><span class="hljs-built_in">cat</span> /usr/local/cuda-12.4/include/cudnn_version.h | grep CUDNN_MAJOR -A 2<br></code></pre></td></tr></table></figure></li></ul><p><span style="font-size:12pt;font-weight:bold;color:green">注:</span> Windows 安装 cuDNN, 下载相应的 <code>.zip</code> 文件 → 解压缩 → 复制 <code>bin, lib, include</code> 三个文件夹到 <code>CUDA 的安装目录</code></p><h1 id="Ubuntu-显卡驱动更新"><a href="#Ubuntu-显卡驱动更新" class="headerlink" title="Ubuntu 显卡驱动更新"></a>Ubuntu 显卡驱动更新</h1><ul><li><p>基本命令 (sudo 运行)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update<br>apt install software-properties-common  <span class="hljs-comment"># 为了使用 add-apt-repository 命令</span><br>apt install ubuntu-drivers-common  <span class="hljs-comment"># 为了使用 ubuntu-drivers 命令</span><br><span class="hljs-comment"># 添加 NVIDIA PPA</span><br>add-apt-repository ppa:graphics-drivers/ppa<br>apt update<br><span class="hljs-comment"># 查找可用的 NVIDIA 驱动驱动程序</span><br>ubuntu-drivers devices  <span class="hljs-comment"># 或 apt search nvidia-driver</span><br>apt install nvidia-driver-&lt;version&gt;<br><span class="hljs-comment"># 重启计算机</span><br></code></pre></td></tr></table></figure></li><li><p>PyTorch 无法使用 (<code>CUDA unknown error</code>)</p><ul><li><a href="https://blog.csdn.net/qq_43428139/article/details/133498358">白帽子续命指南. RuntimeError: CUDA unknown error - this may be due to an incorrectly set up environme… .CSDN</a></li></ul></li></ul><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><ul><li>ubuntu 安装 Tensorflow<ul><li><a href="https://blog.csdn.net/m0_51302496/article/details/137185657">配置Tensorflow使用CUDA进行GPU加速(超详细教程)</a></li></ul></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://blog.csdn.net/bird11111/article/details/105746686">一颗牙牙. 下载各版本cuda，下载以前版本的cuda. CSDN</a><br>[2] <a href="https://www.cnblogs.com/yhjoker/p/10972795.html"><strong>yhjoker. Pytorch 使用不同版本的 cuda. 博客园</strong></a><br>[3] <a href="https://zhuanlan.zhihu.com/p/91334380"><strong>marsggbo. 显卡，显卡驱动,nvcc, cuda driver,cudatoolkit,cudnn到底是什么？知乎</strong></a><br>[4] <a href="https://blog.csdn.net/qq_42406643/article/details/109545766">tomorrow″. 理清GPU、CUDA、CUDA Toolkit、cuDNN关系以及下载安装. CSDN</a><br>[5] <a href="https://blog.csdn.net/weixin_37926734/article/details/123033286">嵌入式技术. Ubuntu20.04下CUDA、cuDNN的详细安装与配置过程（图文）.CSDN</a><br>[6] <a href="https://blog.csdn.net/AI_BING_/article/details/129316768?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpytorch%E7%94%A8%E7%9A%84cuda%E7%89%88%E6%9C%AC&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-129316768.142%5Ev73%5Einsert_down3,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">我是好人BING. 如何正确查看pytorch运行时真正调用的cuda版本. CSDN</a></p>]]></content>
    
    
    <summary type="html">辨析 conda 内外安装的 CUDA Toolkit</summary>
    
    
    
    <category term="Others" scheme="https://zonglin-tian.github.io/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>Typing</title>
    <link href="https://zonglin-tian.github.io/typing/"/>
    <id>https://zonglin-tian.github.io/typing/</id>
    <published>2024-10-08T11:35:00.000Z</published>
    <updated>2025-06-19T06:03:06.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五笔理论"><a href="#五笔理论" class="headerlink" title="五笔理论"></a>五笔理论</h1><h2 id="字型"><a href="#字型" class="headerlink" title="字型"></a>字型</h2><ul><li>杂合型<ul><li>字根相连&#x2F;相交构成的字</li><li>一个基本字根和一个单笔划相连: 自, 千, 尺, 且, 本</li><li>一个基本字根之前或之后有孤立的点: 勺, 术, 太, 主, 斗</li></ul></li></ul><h2 id="末笔-字根"><a href="#末笔-字根" class="headerlink" title="末笔 (字根)"></a>末笔 (字根)</h2><ul><li>万方力九兆乃折 ← 七, 匕</li><li>包框走之看被围</li><li>戈戋我成戊末撇</li><li>单独点字以点作末笔 (I): 义, 太, 勺</li></ul><h2 id="易错字"><a href="#易错字" class="headerlink" title="易错字"></a>易错字</h2><ul><li>乘: tuxv</li></ul><h1 id="练习方法"><a href="#练习方法" class="headerlink" title="练习方法"></a>练习方法</h1><ol start="0"><li>电脑安装<strong>金山打字通</strong>软件</li><li>打开软件 → <code>新手入门</code> (打字常识和字母键位部分非常重要)</li><li><code>英文打字</code> → 直接进行 <code>文章练习</code> (<strong>最为重要</strong>)</li><li><code>拼音打字</code> → <code>词组练习</code> or <code>文章练习</code></li><li><em>五笔打字</em></li></ol><h1 id="练习记录"><a href="#练习记录" class="headerlink" title="练习记录"></a>练习记录</h1><h2 id="五笔单字"><a href="#五笔单字" class="headerlink" title="五笔单字"></a>五笔单字</h2><ul><li>2024-10-04 (一级简码综合 1)</li><li>2024-10-18 (常用字 1)</li></ul><h2 id="英文文章"><a href="#英文文章" class="headerlink" title="英文文章"></a>英文文章</h2><ul><li>2024-10-04 (The road to modern English)</li><li>2024-10-18 (Journey down…)</li><li>2024-11-15 (practice health…)</li></ul><h1 id="最佳速度"><a href="#最佳速度" class="headerlink" title="最佳速度"></a>最佳速度</h1><ul><li>英文文章: 215 字&#x2F;分 (2024-10-18)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Others" scheme="https://zonglin-tian.github.io/categories/Others/"/>
    
    
  </entry>
  
</feed>
